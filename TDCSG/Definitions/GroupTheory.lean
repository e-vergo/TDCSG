/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import TDCSG.Definitions.GroupAction
import Mathlib.Algebra.Group.Subgroup.Lattice
import Mathlib.GroupTheory.GroupAction.Basic

/-!
# Compound Symmetry Group - Proper Group-Theoretic Definition

This file defines the compound symmetry group GG(n,m) as a subgroup of permutations of ℂ,
following the paper "Two-Disk Compound Symmetry Groups" (arXiv:2302.12950v1).

## Mathematical Background

The generators A and B are piecewise isometries:
- A: rotation by -2π/5 about (-1) inside the left disk, identity outside
- B: rotation by -2π/5 about (+1) inside the right disk, identity outside

These are bijections (order 5 elements: A⁵ = B⁵ = id), so they define elements of `Equiv.Perm ℂ`.
The compound symmetry group is the subgroup generated by A and B.

## Main Definitions

- `genA_perm`, `genB_perm` : Generators as elements of `Equiv.Perm ℂ`
- `CompoundSymmetryGroup` : The subgroup of `Equiv.Perm ℂ` generated by A and B
- `GG5` : The compound symmetry group at the critical radius

## Key Properties

- The group acts on ℂ via the natural `MulAction (Equiv.Perm ℂ) ℂ`
- `MulAction.orbit GG5 z` is the orbit of z under the group action
- This matches the word-based `orbit` definition from GroupAction.lean
-/

namespace TDCSG.Definitions

open scoped Complex

/-! ### Generators as Permutations -/

/-- Circle.exp θ ^ n = Circle.exp (n * θ). -/
private lemma Circle_exp_pow (θ : ℝ) (n : ℕ) : Circle.exp θ ^ n = Circle.exp (n * θ) := by
  induction n with
  | zero => simp [Circle.exp_zero]
  | succ n ih =>
    rw [pow_succ, ih, ← Circle.exp_add]
    congr 1
    push_cast
    ring

/-- Circle.exp (-2π) = 1, the fundamental periodicity. -/
private lemma circle_exp_neg_two_pi : Circle.exp (-2 * Real.pi) = 1 := by
  apply Subtype.ext
  simp only [Circle.coe_exp, Circle.coe_one]
  push_cast
  have h : (-2 : ℂ) * ↑Real.pi * Complex.I = -(2 * ↑Real.pi * Complex.I) := by ring
  rw [h, Complex.exp_neg, Complex.exp_two_pi_mul_I, inv_one]

/-- 5 rotations by -2π/5 = identity (key for order 5). -/
private lemma Circle_exp_neg_two_pi_over_5_pow_5 : Circle.exp (-2 * Real.pi / 5) ^ 5 = 1 := by
  rw [Circle_exp_pow]
  have h : (5 : ℕ) * (-2 * Real.pi / 5) = -2 * Real.pi := by ring
  rw [h]
  exact circle_exp_neg_two_pi

/-- genA acts as identity outside the left disk. -/
private lemma genA_outside (r : ℝ) (z : ℂ) (hz : z ∉ leftDisk r) : genA r z = z := by
  unfold genA
  simp only [hz, ↓reduceIte]

/-- genA acts as rotation inside the left disk. -/
private lemma genA_inside (r : ℝ) (z : ℂ) (hz : z ∈ leftDisk r) :
    genA r z = rotateAboutCircle leftCenter (Circle.exp (-2 * Real.pi / 5)) z := by
  unfold genA
  simp only [hz, ↓reduceIte]
  rw [rotateAboutCircle_eq_rotateAboutC]

/-- Rotation about leftCenter preserves leftDisk membership. -/
private lemma rotateAboutCircle_leftCenter_preserves_leftDisk (a : Circle) (r : ℝ) (z : ℂ)
    (hz : z ∈ leftDisk r) : rotateAboutCircle leftCenter a z ∈ leftDisk r := by
  unfold leftDisk
  have h_center : leftCenter = (-1 : ℂ) := by unfold leftCenter; simp
  rw [h_center]
  exact rotateAboutCircle_preserves_disk (-1) a r z hz

/-- Generator A has order 5: applying it 5 times gives the identity. -/
private lemma genA_pow_five (r : ℝ) (z : ℂ) :
    genA r (genA r (genA r (genA r (genA r z)))) = z := by
  by_cases hz : z ∈ leftDisk r
  · -- Inside case: 5 rotations = identity
    set a := Circle.exp (-2 * Real.pi / 5) with ha
    set rot := rotateAboutCircle leftCenter a with hrot
    -- Each genA application preserves disk membership and equals rotation
    have step1 : genA r z = rot z := genA_inside r z hz
    have mem1 : rot z ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r z hz
    have step2 : genA r (rot z) = rot (rot z) := genA_inside r (rot z) mem1
    have mem2 : rot (rot z) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem1
    have step3 : genA r (rot (rot z)) = rot (rot (rot z)) := genA_inside r _ mem2
    have mem3 : rot (rot (rot z)) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem2
    have step4 : genA r (rot (rot (rot z))) = rot (rot (rot (rot z))) := genA_inside r _ mem3
    have mem4 : rot (rot (rot (rot z))) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem3
    have step5 : genA r (rot (rot (rot (rot z)))) = rot (rot (rot (rot (rot z)))) := genA_inside r _ mem4
    -- Chain together: 5 genA applications = 5 rotations = rotation by power 5
    calc genA r (genA r (genA r (genA r (genA r z))))
        = genA r (genA r (genA r (genA r (rot z)))) := by rw [step1]
      _ = genA r (genA r (genA r (rot (rot z)))) := by rw [step2]
      _ = genA r (genA r (rot (rot (rot z)))) := by rw [step3]
      _ = genA r (rot (rot (rot (rot z)))) := by rw [step4]
      _ = rot (rot (rot (rot (rot z)))) := by rw [step5]
      _ = rotateAboutCircle leftCenter (a * (a * (a * (a * a)))) z := by
          simp only [hrot, ← rotateAboutCircle_mul]
      _ = rotateAboutCircle leftCenter (a ^ 5) z := by
          congr 1; simp only [pow_succ, pow_zero, one_mul, mul_assoc]
      _ = rotateAboutCircle leftCenter 1 z := by rw [ha, Circle_exp_neg_two_pi_over_5_pow_5]
      _ = z := rotateAboutCircle_one leftCenter z
  · -- Outside case: genA is identity
    simp only [genA_outside r z hz]

/-- Generator A is a bijection: it has order 5 (A⁵ = id). -/
lemma genA_bijective (r : ℝ) : Function.Bijective (genA r) := by
  constructor
  · -- Injective: if genA x = genA y, apply genA⁴ to both sides
    intro x y hxy
    have hx : genA r (genA r (genA r (genA r (genA r x)))) = x := genA_pow_five r x
    have hy : genA r (genA r (genA r (genA r (genA r y)))) = y := genA_pow_five r y
    -- Apply genA r four times to both sides of hxy
    have h1 : genA r (genA r x) = genA r (genA r y) := congrArg (genA r) hxy
    have h2 : genA r (genA r (genA r x)) = genA r (genA r (genA r y)) := congrArg (genA r) h1
    have h3 : genA r (genA r (genA r (genA r x))) = genA r (genA r (genA r (genA r y))) := congrArg (genA r) h2
    have h4 : genA r (genA r (genA r (genA r (genA r x)))) = genA r (genA r (genA r (genA r (genA r y)))) := congrArg (genA r) h3
    rw [hx, hy] at h4
    exact h4
  · -- Surjective: preimage of y is genA⁴ y
    intro y
    use genA r (genA r (genA r (genA r y)))
    exact genA_pow_five r y

/-- genB acts as identity outside the right disk. -/
private lemma genB_outside (r : ℝ) (z : ℂ) (hz : z ∉ rightDisk r) : genB r z = z := by
  unfold genB
  simp only [hz, ↓reduceIte]

/-- genB acts as rotation inside the right disk. -/
private lemma genB_inside (r : ℝ) (z : ℂ) (hz : z ∈ rightDisk r) :
    genB r z = rotateAboutCircle rightCenter (Circle.exp (-2 * Real.pi / 5)) z := by
  unfold genB
  simp only [hz, ↓reduceIte]
  rw [rotateAboutCircle_eq_rotateAboutC]

/-- Rotation about rightCenter preserves rightDisk membership. -/
private lemma rotateAboutCircle_rightCenter_preserves_rightDisk (a : Circle) (r : ℝ) (z : ℂ)
    (hz : z ∈ rightDisk r) : rotateAboutCircle rightCenter a z ∈ rightDisk r := by
  unfold rightDisk
  have h_center : rightCenter = (1 : ℂ) := by unfold rightCenter; simp
  rw [h_center]
  exact rotateAboutCircle_preserves_disk 1 a r z hz

/-- Generator B has order 5: applying it 5 times gives the identity. -/
private lemma genB_pow_five (r : ℝ) (z : ℂ) :
    genB r (genB r (genB r (genB r (genB r z)))) = z := by
  by_cases hz : z ∈ rightDisk r
  · -- Inside case: 5 rotations = identity
    set a := Circle.exp (-2 * Real.pi / 5) with ha
    set rot := rotateAboutCircle rightCenter a with hrot
    -- Each genB application preserves disk membership and equals rotation
    have step1 : genB r z = rot z := genB_inside r z hz
    have mem1 : rot z ∈ rightDisk r := rotateAboutCircle_rightCenter_preserves_rightDisk a r z hz
    have step2 : genB r (rot z) = rot (rot z) := genB_inside r (rot z) mem1
    have mem2 : rot (rot z) ∈ rightDisk r := rotateAboutCircle_rightCenter_preserves_rightDisk a r _ mem1
    have step3 : genB r (rot (rot z)) = rot (rot (rot z)) := genB_inside r _ mem2
    have mem3 : rot (rot (rot z)) ∈ rightDisk r := rotateAboutCircle_rightCenter_preserves_rightDisk a r _ mem2
    have step4 : genB r (rot (rot (rot z))) = rot (rot (rot (rot z))) := genB_inside r _ mem3
    have mem4 : rot (rot (rot (rot z))) ∈ rightDisk r := rotateAboutCircle_rightCenter_preserves_rightDisk a r _ mem3
    have step5 : genB r (rot (rot (rot (rot z)))) = rot (rot (rot (rot (rot z)))) := genB_inside r _ mem4
    -- Chain together: 5 genB applications = 5 rotations = rotation by power 5
    calc genB r (genB r (genB r (genB r (genB r z))))
        = genB r (genB r (genB r (genB r (rot z)))) := by rw [step1]
      _ = genB r (genB r (genB r (rot (rot z)))) := by rw [step2]
      _ = genB r (genB r (rot (rot (rot z)))) := by rw [step3]
      _ = genB r (rot (rot (rot (rot z)))) := by rw [step4]
      _ = rot (rot (rot (rot (rot z)))) := by rw [step5]
      _ = rotateAboutCircle rightCenter (a * (a * (a * (a * a)))) z := by
          simp only [hrot, ← rotateAboutCircle_mul]
      _ = rotateAboutCircle rightCenter (a ^ 5) z := by
          congr 1; simp only [pow_succ, pow_zero, one_mul, mul_assoc]
      _ = rotateAboutCircle rightCenter 1 z := by rw [ha, Circle_exp_neg_two_pi_over_5_pow_5]
      _ = z := rotateAboutCircle_one rightCenter z
  · -- Outside case: genB is identity
    simp only [genB_outside r z hz]

/-- Generator B is a bijection: it has order 5 (B⁵ = id). -/
lemma genB_bijective (r : ℝ) : Function.Bijective (genB r) := by
  constructor
  · -- Injective: if genB x = genB y, apply genB⁴ to both sides
    intro x y hxy
    have hx : genB r (genB r (genB r (genB r (genB r x)))) = x := genB_pow_five r x
    have hy : genB r (genB r (genB r (genB r (genB r y)))) = y := genB_pow_five r y
    -- Apply genB r four times to both sides of hxy
    have h1 : genB r (genB r x) = genB r (genB r y) := congrArg (genB r) hxy
    have h2 : genB r (genB r (genB r x)) = genB r (genB r (genB r y)) := congrArg (genB r) h1
    have h3 : genB r (genB r (genB r (genB r x))) = genB r (genB r (genB r (genB r y))) := congrArg (genB r) h2
    have h4 : genB r (genB r (genB r (genB r (genB r x)))) = genB r (genB r (genB r (genB r (genB r y)))) := congrArg (genB r) h3
    rw [hx, hy] at h4
    exact h4
  · -- Surjective: preimage of y is genB⁴ y
    intro y
    use genB r (genB r (genB r (genB r y)))
    exact genB_pow_five r y

/-- Generator A as an element of `Equiv.Perm ℂ`. -/
noncomputable def genA_perm (r : ℝ) : Equiv.Perm ℂ :=
  Equiv.ofBijective (genA r) (genA_bijective r)

/-- Generator B as an element of `Equiv.Perm ℂ`. -/
noncomputable def genB_perm (r : ℝ) : Equiv.Perm ℂ :=
  Equiv.ofBijective (genB r) (genB_bijective r)

/-- The action of genA_perm agrees with genA. -/
@[simp]
lemma genA_perm_apply (r : ℝ) (z : ℂ) : genA_perm r z = genA r z := rfl

/-- The action of genB_perm agrees with genB. -/
@[simp]
lemma genB_perm_apply (r : ℝ) (z : ℂ) : genB_perm r z = genB r z := rfl

/-! ### Compound Symmetry Group -/

/-- The compound symmetry group at radius r: the subgroup of `Equiv.Perm ℂ`
    generated by the two rotation generators A and B.

    This is the proper group-theoretic definition of GG(n,m) from the paper. -/
noncomputable def TwoDiskCompoundSymmetryGroup (r : ℝ) : Subgroup (Equiv.Perm ℂ) :=
  Subgroup.closure {genA_perm r, genB_perm r}

/-- GG5: The compound symmetry group GG(5,5) at the critical radius.

    This is the main object of study in the paper. -/
noncomputable def GG5_At_Critical_radius : Subgroup (Equiv.Perm ℂ) :=
  TwoDiskCompoundSymmetryGroup r_crit

/-! ### Group Action and Orbits -/

/-- The MulAction orbit of a point under the compound symmetry group.

    This uses Mathlib's standard `MulAction.orbit` which gives the set
    `{g • z | g ∈ G}` for a group G acting on a type. -/
noncomputable def groupOrbit (r : ℝ) (z : ℂ) : Set ℂ :=
  MulAction.orbit (TwoDiskCompoundSymmetryGroup r) z

/-- The GG5 orbit of a point. -/
noncomputable def GG5_orbit (z : ℂ) : Set ℂ :=
  MulAction.orbit GG5_At_Critical_radius z

end TDCSG.Definitions
