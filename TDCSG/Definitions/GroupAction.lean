/-
Copyright (c) 2024 Eric Vergo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Vergo
-/
import TDCSG.Definitions.Core
import TDCSG.Definitions.Geometry
import Mathlib.Algebra.Group.Subgroup.Lattice

/-!
# Group Action Definitions

This file defines the group action of the two-disk compound symmetry groups on the complex plane.
It establishes the bridge between geometric transformations (rotations inside disks) and
algebraic group theory (permutation groups).

## Architectural Overview

The file proceeds in layers:
1. **Geometric primitives**: Specialized 5-fold generators (genA, genB) as piecewise isometries
2. **Bijectivity proofs**: Establish that generators are bijections (invertible transformations)
3. **Permutation lift**: Convert bijections to permutation group elements
4. **Group structure**: Define the subgroup generated by the permutations
5. **Word application**: Apply sequences of generators to points

## Main definitions

- `genA r`: The 5-fold generator A at radius r (rotation by -2π/5 in left disk)
- `genB r`: The 5-fold generator B at radius r (rotation by -2π/5 in right disk)
- `genA_n_perm n hn r`: Generator A as a permutation of ℂ
- `genB_n_perm n hn r`: Generator B as a permutation of ℂ
- `TwoDiskCompoundSymmetryGroup n hn r`: The group GG(n,n) at radius r
- `applyGen r z g`: Apply generator g to point z at radius r
- `applyWord r w z`: Apply word w to point z at radius r
- `orbit r z`: The orbit of point z under the group action at radius r

## Main statements

- `genA_n_bijective`: The n-fold generator A is bijective for all n ≥ 1
- `genB_n_bijective`: The n-fold generator B is bijective for all n ≥ 1
- `genA_n_pow_n`: The n-fold generator A has order n (A^n = id)
- `genB_n_pow_n`: The n-fold generator B has order n (B^n = id)

## Implementation Notes

Generators are defined as piecewise functions using decidable membership in disks.
The `by classical` tactic is used to provide decidability, making the definitions
noncomputable. This is standard for geometric transformations in Mathlib.

The iteration notation `f^[n]` (from `Function.iterate`) is used throughout to
represent repeated application, making the code more readable and easier to reason about.

## References

* [arXiv:2302.12950v1](https://arxiv.org/abs/2302.12950)
-/

namespace TDCSG.Definitions

open Real Complex
open scoped Circle

/-- The 5-fold generator A at radius r: rotates by -2π/5 inside the left disk,
acts as identity outside. -/
noncomputable def genA (r : ℝ) (z : ℂ) : ℂ := by
  classical
  exact if z ∈ leftDisk r then rotateAboutC leftCenter (-2 * π / 5) z else z

/-- The 5-fold generator B at radius r: rotates by -2π/5 inside the right disk,
acts as identity outside. -/
noncomputable def genB (r : ℝ) (z : ℂ) : ℂ := by
  classical
  exact if z ∈ rightDisk r then rotateAboutC rightCenter (-2 * π / 5) z else z

/-- Exponentiation of `Circle.exp` distributes over multiplication in the exponent.
This is the circle group analogue of the law `exp(nθ) = exp(θ)^n` for complex exponentials. -/
lemma Circle_exp_pow (theta : ℝ) (n : ℕ) : Circle.exp theta ^ n = Circle.exp (n * theta) := by
  induction n with
  | zero => simp [Circle.exp_zero]
  | succ n ih =>
    rw [pow_succ, ih, <- Circle.exp_add]
    congr 1
    push_cast
    ring

/-- Rotation by -2π (one full turn clockwise) is the identity in the circle group.
This is the periodicity property of the exponential map to the unit circle. -/
lemma circle_exp_neg_two_pi : Circle.exp (-2 * π) = 1 := by
  apply Subtype.ext
  simp only [Circle.coe_exp, Circle.coe_one]
  push_cast
  have h : (-2 : ℂ) * π * I = -(2 * π * I) := by ring
  rw [h, Complex.exp_neg, Complex.exp_two_pi_mul_I, inv_one]

/-- Rotating by -2π/n exactly n times brings you back to the start.
This establishes that the n-fold generators have order exactly n. -/
lemma Circle_exp_neg_two_pi_over_n_pow_n (n : ℕ) (hn : n ≥ 1) :
    Circle.exp (-2 * π / n) ^ n = 1 := by
  rw [Circle_exp_pow]
  have h : (n : ℝ) * (-2 * π / n) = -2 * π := by field_simp
  rw [h]
  exact circle_exp_neg_two_pi

/-- Rotation about the left center preserves membership in the left disk.
This is geometrically obvious: rotating a point about the center of a disk keeps it in that disk. -/
lemma rotateAboutCircle_leftCenter_preserves_leftDisk (a : Circle) (r : ℝ) (z : ℂ)
    (hz : z ∈ leftDisk r) : rotateAboutCircle leftCenter a z ∈ leftDisk r := by
  unfold leftDisk
  have h_center : leftCenter = (-1 : ℂ) := by unfold leftCenter; simp
  rw [h_center]
  exact rotateAboutCircle_preserves_disk (-1) a r z hz

/-- Rotation about the right center preserves membership in the right disk.
This is geometrically obvious: rotating a point about the center of a disk keeps it in that disk. -/
lemma rotateAboutCircle_rightCenter_preserves_rightDisk (a : Circle) (r : ℝ) (z : ℂ)
    (hz : z ∈ rightDisk r) : rotateAboutCircle rightCenter a z ∈ rightDisk r := by
  unfold rightDisk
  have h_center : rightCenter = (1 : ℂ) := by unfold rightCenter; simp
  rw [h_center]
  exact rotateAboutCircle_preserves_disk 1 a r z hz

/-- Generator A acts as the identity on points outside the left disk.
This is a defining property of the piecewise isometry: it only affects points within its disk. -/
lemma genA_n_outside (n : ℕ) (r : ℝ) (z : ℂ) (hz : z ∉ leftDisk r) :
    genA_n n r z = z := by
  unfold genA_n
  simp only [hz, if_false]

/-- Generator A rotates points inside the left disk by -2π/n about the left center.
This is the rotation behavior on points within the disk, forming a fractional rotation of order n. -/
lemma genA_n_inside (n : ℕ) (r : ℝ) (z : ℂ) (hz : z ∈ leftDisk r) :
    genA_n n r z = rotateAboutCircle leftCenter (Circle.exp (-2 * π / n)) z := by
  unfold genA_n
  simp only [hz, if_true]
  rw [rotateAboutCircle_eq_rotateAboutC]

/-- Generator B acts as the identity on points outside the right disk.
This is a defining property of the piecewise isometry: it only affects points within its disk. -/
lemma genB_n_outside (n : ℕ) (r : ℝ) (z : ℂ) (hz : z ∉ rightDisk r) :
    genB_n n r z = z := by
  unfold genB_n
  simp only [hz, if_false]

/-- Generator B rotates points inside the right disk by -2π/n about the right center.
This is the rotation behavior on points within the disk, forming a fractional rotation of order n. -/
lemma genB_n_inside (n : ℕ) (r : ℝ) (z : ℂ) (hz : z ∈ rightDisk r) :
    genB_n n r z = rotateAboutCircle rightCenter (Circle.exp (-2 * π / n)) z := by
  unfold genB_n
  simp only [hz, if_true]
  rw [rotateAboutCircle_eq_rotateAboutC]

/-- Iterated rotation about the left center preserves membership in the left disk.
By induction: each single rotation preserves the disk, so any finite iteration does. -/
lemma rotateAboutCircle_leftCenter_iterate_preserves_leftDisk' (a : Circle) (r : ℝ) (k : ℕ)
    (w : ℂ) (hw : w ∈ leftDisk r) :
    (rotateAboutCircle leftCenter a)^[k] w ∈ leftDisk r := by
  induction k with
  | zero => simpa
  | succ k ih =>
    simp only [Function.iterate_succ', Function.comp_apply]
    exact rotateAboutCircle_leftCenter_preserves_leftDisk a r _ ih

/-- Iterated rotation about the right center preserves membership in the right disk.
By induction: each single rotation preserves the disk, so any finite iteration does. -/
lemma rotateAboutCircle_rightCenter_iterate_preserves_rightDisk' (a : Circle) (r : ℝ) (k : ℕ)
    (w : ℂ) (hw : w ∈ rightDisk r) :
    (rotateAboutCircle rightCenter a)^[k] w ∈ rightDisk r := by
  induction k with
  | zero => simpa
  | succ k ih =>
    simp only [Function.iterate_succ', Function.comp_apply]
    exact rotateAboutCircle_rightCenter_preserves_rightDisk a r _ ih

/-- Generator A has order n: applying it n times returns to the identity.

The proof splits into two cases:
- Inside the left disk: rotation by -2π/n repeated n times equals rotation by -2π = identity
- Outside the left disk: the generator is already the identity

This is the fundamental periodicity property that makes GG(n,n) have n-torsion. -/
lemma genA_n_pow_n (n : ℕ) (hn : n ≥ 1) (r : ℝ) (z : ℂ) :
    (genA_n n r)^[n] z = z := by
  by_cases hz : z ∈ leftDisk r
  .
    set a := Circle.exp (-2 * π / n) with ha

    have h_eq_rot : forall k : ℕ, forall w : ℂ, w ∈ leftDisk r ->
        (genA_n n r)^[k] w = (rotateAboutCircle leftCenter a)^[k] w := by
      intro k
      induction k with
      | zero => simp
      | succ k ih =>
        intro w hw
        simp only [Function.iterate_succ', Function.comp_apply]
        have hw' : (rotateAboutCircle leftCenter a)^[k] w ∈ leftDisk r :=
          rotateAboutCircle_leftCenter_iterate_preserves_leftDisk' a r k w hw
        rw [ih w hw]
        rw [genA_n_inside n r _ hw']
    rw [h_eq_rot n z hz]

    rw [rotateAboutCircle_pow]
    rw [ha, Circle_exp_neg_two_pi_over_n_pow_n n hn]
    exact rotateAboutCircle_one leftCenter z
  .
    have h_id : forall k : ℕ, (genA_n n r)^[k] z = z := by
      intro k
      induction k with
      | zero => simp
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply, ih]
        exact genA_n_outside n r z hz
    exact h_id n

/-- Generator B has order n: applying it n times returns to the identity.

The proof is symmetric to `genA_n_pow_n`:
- Inside the right disk: rotation by -2π/n repeated n times equals rotation by -2π = identity
- Outside the right disk: the generator is already the identity

This is the fundamental periodicity property for the right generator. -/
lemma genB_n_pow_n (n : ℕ) (hn : n ≥ 1) (r : ℝ) (z : ℂ) :
    (genB_n n r)^[n] z = z := by
  by_cases hz : z ∈ rightDisk r
  .
    set a := Circle.exp (-2 * π / n) with ha

    have h_eq_rot : forall k : ℕ, forall w : ℂ, w ∈ rightDisk r ->
        (genB_n n r)^[k] w = (rotateAboutCircle rightCenter a)^[k] w := by
      intro k
      induction k with
      | zero => simp
      | succ k ih =>
        intro w hw
        simp only [Function.iterate_succ', Function.comp_apply]
        have hw' : (rotateAboutCircle rightCenter a)^[k] w ∈ rightDisk r :=
          rotateAboutCircle_rightCenter_iterate_preserves_rightDisk' a r k w hw
        rw [ih w hw]
        rw [genB_n_inside n r _ hw']
    rw [h_eq_rot n z hz]

    rw [rotateAboutCircle_pow]
    rw [ha, Circle_exp_neg_two_pi_over_n_pow_n n hn]
    exact rotateAboutCircle_one rightCenter z
  .
    have h_id : forall k : ℕ, (genB_n n r)^[k] z = z := by
      intro k
      induction k with
      | zero => simp
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply, ih]
        exact genB_n_outside n r z hz
    exact h_id n

/-- Rewriting `f^[n] x` as `f^[n-1] (f x)`: "peel off" the first application.
This is useful for induction arguments where we need to relate n iterations to n-1 iterations. -/
lemma iterate_split (f : ℂ -> ℂ) (n : ℕ) (hn : n ≥ 1) (x : ℂ) :
    f^[n] x = f^[n - 1] (f x) := by
  have h : n = (n - 1) + 1 := (Nat.sub_add_cancel hn).symm
  conv_lhs => rw [h]
  rw [Function.iterate_succ_apply']
  exact (Function.Commute.iterate_self f (n - 1) x).symm

/-- Rewriting `f (f^[n-1] x)` as `f^[n] x`: "add on" one more application.
This is the converse of `iterate_split`, useful for constructing surjectivity proofs. -/
lemma iterate_unsplit (f : ℂ -> ℂ) (n : ℕ) (hn : n ≥ 1) (x : ℂ) :
    f (f^[n - 1] x) = f^[n] x := by
  have h : n = (n - 1) + 1 := (Nat.sub_add_cancel hn).symm
  conv_rhs => rw [h]
  exact (Function.iterate_succ_apply' f (n - 1) x).symm

/-- The n-fold generator A is bijective.

Injectivity follows from periodicity: if A(x) = A(y), then applying A^(n-1) to both
sides and using A^n = id gives x = y.

Surjectivity is constructive: for any y, we can find its preimage as A^(n-1)(y),
which satisfies A(A^(n-1)(y)) = A^n(y) = y.

This bijectivity is what allows us to view the generator as a permutation of ℂ. -/
lemma genA_n_bijective (n : ℕ) (hn : n ≥ 1) (r : ℝ) : Function.Bijective (genA_n n r) := by

  have h_period : forall z, (genA_n n r)^[n] z = z := fun z => genA_n_pow_n n hn r z
  constructor
  .
    intro x y hxy

    have h_apply : forall k, (genA_n n r)^[k] (genA_n n r x) = (genA_n n r)^[k] (genA_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genA_n n r) ih
    have h_eq : (genA_n n r)^[n] x = (genA_n n r)^[n] y := by
      calc (genA_n n r)^[n] x
          = (genA_n n r)^[n - 1] (genA_n n r x) := iterate_split (genA_n n r) n hn x
        _ = (genA_n n r)^[n - 1] (genA_n n r y) := h_apply (n - 1)
        _ = (genA_n n r)^[n] y := (iterate_split (genA_n n r) n hn y).symm
    calc x = (genA_n n r)^[n] x := (h_period x).symm
      _ = (genA_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genA_n n r)^[n - 1] y
    calc genA_n n r ((genA_n n r)^[n - 1] y)
        = (genA_n n r)^[n] y := iterate_unsplit (genA_n n r) n hn y
      _ = y := h_period y

/-- The n-fold generator B is bijective.

The proof is symmetric to `genA_n_bijective`:
- Injectivity: if B(x) = B(y), apply B^(n-1) and use B^n = id to get x = y
- Surjectivity: for any y, its preimage is B^(n-1)(y)

This bijectivity allows B to be viewed as a permutation of the complex plane. -/
lemma genB_n_bijective (n : ℕ) (hn : n ≥ 1) (r : ℝ) : Function.Bijective (genB_n n r) := by
  have h_period : forall z, (genB_n n r)^[n] z = z := fun z => genB_n_pow_n n hn r z
  constructor
  .
    intro x y hxy
    have h_apply : forall k, (genB_n n r)^[k] (genB_n n r x) = (genB_n n r)^[k] (genB_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genB_n n r) ih
    have h_eq : (genB_n n r)^[n] x = (genB_n n r)^[n] y := by
      calc (genB_n n r)^[n] x
          = (genB_n n r)^[n - 1] (genB_n n r x) := iterate_split (genB_n n r) n hn x
        _ = (genB_n n r)^[n - 1] (genB_n n r y) := h_apply (n - 1)
        _ = (genB_n n r)^[n] y := (iterate_split (genB_n n r) n hn y).symm
    calc x = (genB_n n r)^[n] x := (h_period x).symm
      _ = (genB_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genB_n n r)^[n - 1] y
    calc genB_n n r ((genB_n n r)^[n - 1] y)
        = (genB_n n r)^[n] y := iterate_unsplit (genB_n n r) n hn y
      _ = y := h_period y

/-- Apply a single generator to a complex point at radius r.

For the forward generators (A, B), this applies the rotation once.
For the inverse generators (A⁻¹, B⁻¹), this applies the forward rotation 4 times,
which equals the inverse since the generators have order 5 (genA^5 = genB^5 = id).

The iteration notation `(genA r)^[4]` is used to express "apply genA four times",
making the inverse relationship explicit and avoiding hard-coded composition. -/
noncomputable def applyGen (r : ℝ) (z : ℂ) : Generator → ℂ
  | .A    => genA r z
  | .Ainv => (genA r)^[4] z
  | .B    => genB r z
  | .Binv => (genB r)^[4] z

/-- Apply a word (sequence of generators) to a point in the complex plane.

Words are applied left-to-right via `foldl`: the word `[A, B, A⁻¹]` computes `A⁻¹(B(A(z)))`.
This convention matches the paper where `ab(x) = b(a(x))` (function composition on the left). -/
noncomputable def applyWord (r : ℝ) (w : Word) (z : ℂ) : ℂ :=
  w.foldl (applyGen r) z

/-- The orbit of a point z under the two-disk compound symmetry group at radius r.

The orbit is the set of all points reachable from z by applying any finite sequence of
generators. For finite groups (r < r_crit), orbits are finite sets. At the critical radius,
certain orbits become infinite, forming the characteristic fractals discussed in the paper.

Mathematically, this is the set `{g(z) | g in GG(n,n)(r)}` where GG(n,n)(r) is the group
generated by the two n-fold rotations. -/
noncomputable def orbit (r : ℝ) (z : ℂ) : Set ℂ :=
  { w | ∃ word : Word, applyWord r word z = w }

/-- The n-fold rotation generator A as a permutation of ℂ.
Rotates by -2π/n about the left center (-1) inside the left disk, identity outside.

This is the permutation group representation of `genA_n`, constructed from its bijectivity proof.
The generator is bijective because it acts as a rotation inside the left disk (which is bijective)
and as the identity outside (trivially bijective). -/
noncomputable def genA_n_perm (n : ℕ) (hn : n ≥ 1) (r : ℝ) : Equiv.Perm ℂ :=
  Equiv.ofBijective (genA_n n r) (genA_n_bijective n hn r)

/-- The n-fold rotation generator B as a permutation of ℂ.
Rotates by -2π/n about the right center (+1) inside the right disk, identity outside.

This is the permutation group representation of `genB_n`, constructed from its bijectivity proof.
The generator is bijective because it acts as a rotation inside the right disk (which is bijective)
and as the identity outside (trivially bijective). -/
noncomputable def genB_n_perm (n : ℕ) (hn : n ≥ 1) (r : ℝ) : Equiv.Perm ℂ :=
  Equiv.ofBijective (genB_n n r) (genB_n_bijective n hn r)

/-- The two-disk compound symmetry group GG(n,n) at radius r.

This is the subgroup of permutations of ℂ generated by the n-fold generators A and B.
The group consists of all finite compositions (including inverses) of the two generators,
forming a free product structure at most radii.

At the critical radius r_crit for n=5, this group becomes infinite due to the golden ratio
structure of the induced interval exchange transformation. -/
noncomputable def TwoDiskCompoundSymmetryGroup (n : ℕ) (hn : n ≥ 1) (r : ℝ) :
    Subgroup (Equiv.Perm ℂ) :=
  Subgroup.closure {genA_n_perm n hn r, genB_n_perm n hn r}

end TDCSG.Definitions
