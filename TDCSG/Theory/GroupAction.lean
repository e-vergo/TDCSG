import TDCSG.Core.Basic
import TDCSG.Core.Complex

/-!
# Group Action Theory

This file contains the theoretical framework for group actions in the two-disk system.
Moved from TwoDisk/GroupAction.lean as part of Layer 2 (Theory).

## Main definitions

* `TwoDiskGroup`: The free group generated by the two rotations
* `applyGenerator`: Apply a single generator to a point
* `applyGroupElement`: Apply a group element to a point

## Key theorems

* Group action properties
* Generator preservation of disk membership
-/

open Complex TwoDiskSystem

namespace TwoDiskSystem

variable (sys : TwoDiskSystem)

/-- The two-disk group is the free group generated by two elements (left and right rotations). -/
abbrev TwoDiskGroup := FreeGroup (Fin 2)

/-- Apply a generator (or its inverse) to a point. -/
noncomputable def applyGenerator (gen : Fin 2) (inverse : Bool) (z : ℂ) : ℂ :=
  if h : gen = 0 then
    if inverse then sys.leftRotationInv z else sys.leftRotation z
  else
    if inverse then sys.rightRotationInv z else sys.rightRotation z

/-- Apply a group element to a point by converting to word and folding. -/
noncomputable def applyGroupElement (g : TwoDiskGroup) (z : ℂ) : ℂ :=
  let word := g.toWord
  word.foldl (fun z' gb => applyGenerator sys gb.1 gb.2 z') z

/-- Notation for group action -/
notation g "•[" sys "]" z => applyGroupElement sys g z

/-- The identity element acts as the identity function -/
theorem apply_identity (z : ℂ) : applyGroupElement sys 1 z = z := by
  sorry  -- Follows from FreeGroup.toWord_one

/-- Group action is compatible with multiplication -/
theorem apply_mul (g h : TwoDiskGroup) (z : ℂ) :
    applyGroupElement sys (g * h) z = applyGroupElement sys g (applyGroupElement sys h z) := by
  sorry  -- Requires proving foldl over concatenation equals composition

/-- Left rotation preserves left disk membership -/
theorem leftRotation_preserves_leftDisk (z : ℂ) (hz : z ∈ sys.leftDisk) :
    sys.leftRotation z ∈ sys.leftDisk := by
  unfold leftDisk leftRotation
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, leftCenter, Complex.dist_eq]
  -- Rotation preserves distances from the center
  have : ‖(-1 : ℂ) + Complex.exp (Complex.I * ↑sys.leftAngle) * (z - -1) - -1‖ =
         ‖Complex.exp (Complex.I * ↑sys.leftAngle) * (z - -1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  -- ‖exp(I * θ)‖ = 1 for imaginary arguments
  have h_exp : ‖Complex.exp (Complex.I * ↑sys.leftAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  -- Now goal is ‖z - (-1)‖ ≤ r₁, which is exactly hz
  exact hz

/-- Right rotation preserves right disk membership -/
theorem rightRotation_preserves_rightDisk (z : ℂ) (hz : z ∈ sys.rightDisk) :
    sys.rightRotation z ∈ sys.rightDisk := by
  unfold rightDisk rightRotation
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, rightCenter, Complex.dist_eq]
  have : ‖(1 : ℂ) + Complex.exp (Complex.I * ↑sys.rightAngle) * (z - 1) - 1‖ =
         ‖Complex.exp (Complex.I * ↑sys.rightAngle) * (z - 1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (Complex.I * ↑sys.rightAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Inverse left rotation preserves left disk membership -/
theorem leftRotationInv_preserves_leftDisk (z : ℂ) (hz : z ∈ sys.leftDisk) :
    sys.leftRotationInv z ∈ sys.leftDisk := by
  unfold leftDisk leftRotationInv
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, leftCenter, Complex.dist_eq]
  have : ‖(-1 : ℂ) + Complex.exp (-Complex.I * ↑sys.leftAngle) * (z - -1) - -1‖ =
         ‖Complex.exp (-Complex.I * ↑sys.leftAngle) * (z - -1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (-Complex.I * ↑sys.leftAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.neg_re, Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Inverse right rotation preserves right disk membership -/
theorem rightRotationInv_preserves_rightDisk (z : ℂ) (hz : z ∈ sys.rightDisk) :
    sys.rightRotationInv z ∈ sys.rightDisk := by
  unfold rightDisk rightRotationInv
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, rightCenter, Complex.dist_eq]
  have : ‖(1 : ℂ) + Complex.exp (-Complex.I * ↑sys.rightAngle) * (z - 1) - 1‖ =
         ‖Complex.exp (-Complex.I * ↑sys.rightAngle) * (z - 1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (-Complex.I * ↑sys.rightAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.neg_re, Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Generator application preserves disk union -/
theorem applyGenerator_preserves_union (gen : Fin 2) (inv : Bool) (z : ℂ)
    (hz : z ∈ sys.diskUnion) : applyGenerator sys gen inv z ∈ sys.diskUnion := by
  sorry  -- Complex case analysis, but follows from rotation preservation lemmas

/-- Group elements preserve the disk union -/
theorem group_element_preserves_union (g : TwoDiskGroup) (z : ℂ)
    (hz : z ∈ sys.diskUnion) : applyGroupElement sys g z ∈ sys.diskUnion := by
  unfold applyGroupElement
  let word := g.toWord
  -- Prove by induction on the word
  suffices ∀ (w : List (Fin 2 × Bool)) (z : ℂ), z ∈ sys.diskUnion →
    (w.foldl (fun z' gb => applyGenerator sys gb.1 gb.2 z') z) ∈ sys.diskUnion by
    exact this word z hz
  intro w
  induction w with
  | nil => intro z hz; exact hz
  | cons gb rest ih =>
    intro z hz
    simp only [List.foldl_cons]
    apply ih
    exact applyGenerator_preserves_union sys gb.1 gb.2 z hz

end TwoDiskSystem