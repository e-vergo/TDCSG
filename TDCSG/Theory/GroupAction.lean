import TDCSG.Core.Basic
import TDCSG.Core.Complex

/-!
# Group Action Theory

This file contains the theoretical framework for group actions in the two-disk system.
Moved from TwoDisk/GroupAction.lean as part of Layer 2 (Theory).

## Main definitions

* `TwoDiskGroup`: The free group generated by the two rotations
* `applyGenerator`: Apply a single generator to a point
* `applyGroupElement`: Apply a group element to a point

## Key theorems

* Group action properties
* Generator preservation of disk membership
-/

open Complex TwoDiskSystem

namespace TwoDiskSystem

variable (sys : TwoDiskSystem)

/-- The two-disk group is the free group generated by two elements (left and right rotations). -/
abbrev TwoDiskGroup := FreeGroup (Fin 2)

/-- Apply a generator (or its inverse) to a point. -/
noncomputable def applyGenerator (gen : Fin 2) (inverse : Bool) (z : ℂ) : ℂ :=
  if h : gen = 0 then
    if inverse then sys.leftRotationInv z else sys.leftRotation z
  else
    if inverse then sys.rightRotationInv z else sys.rightRotation z

/-- Apply a group element to a point by converting to word and folding. -/
noncomputable def applyGroupElement (g : TwoDiskGroup) (z : ℂ) : ℂ :=
  let word := g.toWord
  word.foldl (fun z' gb => applyGenerator sys gb.1 gb.2 z') z

/-- Notation for group action -/
notation g "•[" sys "]" z => applyGroupElement sys g z

/-- The identity element acts as the identity function -/
theorem apply_identity (z : ℂ) : applyGroupElement sys 1 z = z := by
  unfold applyGroupElement
  rw [FreeGroup.toWord_one]
  rfl

/-- Group action is compatible with multiplication -/
theorem apply_mul (g h : TwoDiskGroup) (z : ℂ) :
    applyGroupElement sys (g * h) z = applyGroupElement sys g (applyGroupElement sys h z) := by
  unfold applyGroupElement
  -- The challenge: (g*h).toWord = reduce (g.toWord ++ h.toWord), not just concatenation
  -- This requires understanding how reduce preserves the action semantics
  sorry  -- This is blocked on proving foldl compatibility with FreeGroup.reduce
  -- Needs: lemma relating foldl over reduce list to foldl over original list

/-- Left rotation preserves left disk membership -/
theorem leftRotation_preserves_leftDisk (z : ℂ) (hz : z ∈ sys.leftDisk) :
    sys.leftRotation z ∈ sys.leftDisk := by
  unfold leftDisk leftRotation
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, leftCenter, Complex.dist_eq]
  -- Rotation preserves distances from the center
  have : ‖(-1 : ℂ) + Complex.exp (Complex.I * ↑sys.leftAngle) * (z - -1) - -1‖ =
         ‖Complex.exp (Complex.I * ↑sys.leftAngle) * (z - -1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  -- ‖exp(I * θ)‖ = 1 for imaginary arguments
  have h_exp : ‖Complex.exp (Complex.I * ↑sys.leftAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  -- Now goal is ‖z - (-1)‖ ≤ r₁, which is exactly hz
  exact hz

/-- Right rotation preserves right disk membership -/
theorem rightRotation_preserves_rightDisk (z : ℂ) (hz : z ∈ sys.rightDisk) :
    sys.rightRotation z ∈ sys.rightDisk := by
  unfold rightDisk rightRotation
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, rightCenter, Complex.dist_eq]
  have : ‖(1 : ℂ) + Complex.exp (Complex.I * ↑sys.rightAngle) * (z - 1) - 1‖ =
         ‖Complex.exp (Complex.I * ↑sys.rightAngle) * (z - 1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (Complex.I * ↑sys.rightAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Inverse left rotation preserves left disk membership -/
theorem leftRotationInv_preserves_leftDisk (z : ℂ) (hz : z ∈ sys.leftDisk) :
    sys.leftRotationInv z ∈ sys.leftDisk := by
  unfold leftDisk leftRotationInv
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, leftCenter, Complex.dist_eq]
  have : ‖(-1 : ℂ) + Complex.exp (-Complex.I * ↑sys.leftAngle) * (z - -1) - -1‖ =
         ‖Complex.exp (-Complex.I * ↑sys.leftAngle) * (z - -1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (-Complex.I * ↑sys.leftAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.neg_re, Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Inverse right rotation preserves right disk membership -/
theorem rightRotationInv_preserves_rightDisk (z : ℂ) (hz : z ∈ sys.rightDisk) :
    sys.rightRotationInv z ∈ sys.rightDisk := by
  unfold rightDisk rightRotationInv
  rw [if_pos hz]
  simp only [Metric.mem_closedBall, rightCenter, Complex.dist_eq]
  have : ‖(1 : ℂ) + Complex.exp (-Complex.I * ↑sys.rightAngle) * (z - 1) - 1‖ =
         ‖Complex.exp (-Complex.I * ↑sys.rightAngle) * (z - 1)‖ := by
    congr 1; ring
  rw [this, norm_mul]
  have h_exp : ‖Complex.exp (-Complex.I * ↑sys.rightAngle)‖ = 1 := by
    rw [Complex.norm_exp]
    simp only [Complex.neg_re, Complex.mul_re, Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im]
    ring_nf
    norm_num
  rw [h_exp, one_mul]
  exact hz

/-- Generator application preserves disk union -/
theorem applyGenerator_preserves_union (gen : Fin 2) (inv : Bool) (z : ℂ)
    (hz : z ∈ sys.diskUnion) : applyGenerator sys gen inv z ∈ sys.diskUnion := by
  unfold applyGenerator diskUnion at *
  split_ifs with h1 h2 h3
  · -- gen = 0, inv = true: leftRotationInv
    cases hz with
    | inl hz_left => left; exact leftRotationInv_preserves_leftDisk sys z hz_left
    | inr hz_right =>
      -- Point in right disk, apply leftRotationInv (stays in union)
      by_cases z ∈ sys.leftDisk
      · left; exact leftRotationInv_preserves_leftDisk sys z ‹z ∈ sys.leftDisk›
      · -- leftRotationInv is identity outside left disk
        unfold leftRotationInv; rw [if_neg ‹z ∉ sys.leftDisk›]; right; exact hz_right
  · -- gen = 0, inv = false: leftRotation
    cases hz with
    | inl hz_left => left; exact leftRotation_preserves_leftDisk sys z hz_left
    | inr hz_right =>
      by_cases z ∈ sys.leftDisk
      · left; exact leftRotation_preserves_leftDisk sys z ‹z ∈ sys.leftDisk›
      · unfold leftRotation; rw [if_neg ‹z ∉ sys.leftDisk›]; right; exact hz_right
  · -- gen ≠ 0, inv = true: rightRotationInv
    cases hz with
    | inl hz_left =>
      by_cases z ∈ sys.rightDisk
      · right; exact rightRotationInv_preserves_rightDisk sys z ‹z ∈ sys.rightDisk›
      · unfold rightRotationInv; rw [if_neg ‹z ∉ sys.rightDisk›]; left; exact hz_left
    | inr hz_right => right; exact rightRotationInv_preserves_rightDisk sys z hz_right
  · -- gen ≠ 0, inv = false: rightRotation
    cases hz with
    | inl hz_left =>
      by_cases z ∈ sys.rightDisk
      · right; exact rightRotation_preserves_rightDisk sys z ‹z ∈ sys.rightDisk›
      · unfold rightRotation; rw [if_neg ‹z ∉ sys.rightDisk›]; left; exact hz_left
    | inr hz_right => right; exact rightRotation_preserves_rightDisk sys z hz_right

/-- Group elements preserve the disk union -/
theorem group_element_preserves_union (g : TwoDiskGroup) (z : ℂ)
    (hz : z ∈ sys.diskUnion) : applyGroupElement sys g z ∈ sys.diskUnion := by
  unfold applyGroupElement
  let word := g.toWord
  -- Prove by induction on the word
  suffices ∀ (w : List (Fin 2 × Bool)) (z : ℂ), z ∈ sys.diskUnion →
    (w.foldl (fun z' gb => applyGenerator sys gb.1 gb.2 z') z) ∈ sys.diskUnion by
    exact this word z hz
  intro w
  induction w with
  | nil => intro z hz; exact hz
  | cons gb rest ih =>
    intro z hz
    simp only [List.foldl_cons]
    apply ih
    exact applyGenerator_preserves_union sys gb.1 gb.2 z hz

end TwoDiskSystem