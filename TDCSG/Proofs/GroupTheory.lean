/-
Copyright (c) 2024 Eric Vergo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Vergo
-/
import TDCSG.Definitions.GroupTheory
import TDCSG.Proofs.IETOrbit
import Mathlib.GroupTheory.GroupAction.Basic
import Mathlib.Data.Finite.Defs

/-!
# Group Theory for the GG5 Compound Symmetry Group

This file establishes the group structure of the two-disk compound symmetry group generated by
rotations about two disk centers, proving bijectivity of generators and the equivalence between
word orbits and group orbits.

## Main results

- `genA_bijective_proof`: The generator A (rotation about left disk) is bijective
- `genB_bijective_proof`: The generator B (rotation about right disk) is bijective
- `orbit_eq_groupOrbit`: Word orbits coincide with group-theoretic orbits
- `GG5_infinite_of_infinite_orbit`: An infinite orbit implies the group is infinite
- `GG5_has_infinite_group_orbit`: The GG5 group at critical radius has an infinite orbit

## References

* [arXiv:2302.12950v1](https://arxiv.org/abs/2302.12950)
-/

namespace TDCSG.CompoundSymmetry.GG5

open TDCSG.Definitions
open scoped Complex

lemma Circle_exp_neg_two_pi_over_5_pow_5 : Circle.exp (-2 * Real.pi / 5) ^ 5 = 1 := by
  rw [Circle_exp_pow]
  have h : (5 : Nat) * (-2 * Real.pi / 5) = -2 * Real.pi := by ring
  rw [h]
  exact circle_exp_neg_two_pi

lemma genA_outside (r : Real) (z : Complex) (hz : z ∉ leftDisk r) : genA r z = z := by
  unfold genA
  simp only [hz, if_false]

lemma genA_inside (r : Real) (z : Complex) (hz : z ∈ leftDisk r) :
    genA r z = rotateAboutCircle leftCenter (Circle.exp (-2 * Real.pi / 5)) z := by
  unfold genA
  simp only [hz, if_true]
  rw [rotateAboutCircle_eq_rotateAboutC]

lemma genA_pow_five (r : Real) (z : Complex) :
    genA r (genA r (genA r (genA r (genA r z)))) = z := by
  by_cases hz : z ∈ leftDisk r
  .
    set a := Circle.exp (-2 * Real.pi / 5) with ha
    set rot := rotateAboutCircle leftCenter a with hrot

    have step1 : genA r z = rot z := genA_inside r z hz
    have mem1 : rot z ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r z hz
    have step2 : genA r (rot z) = rot (rot z) := genA_inside r (rot z) mem1
    have mem2 : rot (rot z) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem1
    have step3 : genA r (rot (rot z)) = rot (rot (rot z)) := genA_inside r _ mem2
    have mem3 : rot (rot (rot z)) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem2
    have step4 : genA r (rot (rot (rot z))) = rot (rot (rot (rot z))) := genA_inside r _ mem3
    have mem4 : rot (rot (rot (rot z))) ∈ leftDisk r := rotateAboutCircle_leftCenter_preserves_leftDisk a r _ mem3
    have step5 : genA r (rot (rot (rot (rot z)))) = rot (rot (rot (rot (rot z)))) := genA_inside r _ mem4

    calc genA r (genA r (genA r (genA r (genA r z))))
        = genA r (genA r (genA r (genA r (rot z)))) := by rw [step1]
      _ = genA r (genA r (genA r (rot (rot z)))) := by rw [step2]
      _ = genA r (genA r (rot (rot (rot z)))) := by rw [step3]
      _ = genA r (rot (rot (rot (rot z)))) := by rw [step4]
      _ = rot (rot (rot (rot (rot z)))) := by rw [step5]
      _ = rotateAboutCircle leftCenter (a * (a * (a * (a * a)))) z := by
          simp only [hrot, <- rotateAboutCircle_mul]
      _ = rotateAboutCircle leftCenter (a ^ 5) z := by
          congr 1; simp only [pow_succ, pow_zero, one_mul, mul_assoc]
      _ = rotateAboutCircle leftCenter 1 z := by rw [ha, Circle_exp_neg_two_pi_over_5_pow_5]
      _ = z := rotateAboutCircle_one leftCenter z
  .
    simp only [genA_outside r z hz]

theorem genA_bijective_proof (r : Real) : Function.Bijective (genA r) := by
  constructor
  .
    intro x y hxy
    have hx : genA r (genA r (genA r (genA r (genA r x)))) = x := genA_pow_five r x
    have hy : genA r (genA r (genA r (genA r (genA r y)))) = y := genA_pow_five r y

    have h1 : genA r (genA r x) = genA r (genA r y) := congrArg (genA r) hxy
    have h2 : genA r (genA r (genA r x)) = genA r (genA r (genA r y)) := congrArg (genA r) h1
    have h3 : genA r (genA r (genA r (genA r x))) = genA r (genA r (genA r (genA r y))) := congrArg (genA r) h2
    have h4 : genA r (genA r (genA r (genA r (genA r x)))) = genA r (genA r (genA r (genA r (genA r y)))) := congrArg (genA r) h3
    rw [hx, hy] at h4
    exact h4
  .
    intro y
    use genA r (genA r (genA r (genA r y)))
    exact genA_pow_five r y

lemma genB_outside (r : Real) (z : Complex) (hz : z ∉ rightDisk r) : genB r z = z := by
  unfold genB
  simp only [hz, if_false]

lemma genB_inside (r : Real) (z : Complex) (hz : z ∈ rightDisk r) :
    genB r z = rotateAboutCircle rightCenter (Circle.exp (-2 * Real.pi / 5)) z := by
  unfold genB
  simp only [hz, if_true]
  rw [rotateAboutCircle_eq_rotateAboutC]

lemma genB_pow_five (r : Real) (z : Complex) :
    genB r (genB r (genB r (genB r (genB r z)))) = z := by

  by_cases hz : z ∈ rightDisk r
  .

    have h1 : genB r z ∈ rightDisk r := genB_preserves_rightDisk r z hz
    have h2 : genB r (genB r z) ∈ rightDisk r := genB_preserves_rightDisk r (genB r z) h1
    have h3 : genB r (genB r (genB r z)) ∈ rightDisk r :=
      genB_preserves_rightDisk r (genB r (genB r z)) h2
    have h4 : genB r (genB r (genB r (genB r z))) ∈ rightDisk r :=
      genB_preserves_rightDisk r (genB r (genB r (genB r z))) h3

    set omega := Circle.exp (-2 * Real.pi / 5) with homega_def

    calc genB r (genB r (genB r (genB r (genB r z))))
        = rotateAboutCircle rightCenter omega (genB r (genB r (genB r (genB r z)))) :=
          genB_in_disk_eq_rotateAboutCircle r _ h4
      _ = rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega (genB r (genB r (genB r z)))) := by
          rw [genB_in_disk_eq_rotateAboutCircle r _ h3]
      _ = rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega
            (rotateAboutCircle rightCenter omega (genB r (genB r z)))) := by
          rw [genB_in_disk_eq_rotateAboutCircle r _ h2]
      _ = rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega
            (rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega (genB r z)))) := by
          rw [genB_in_disk_eq_rotateAboutCircle r _ h1]
      _ = rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega
            (rotateAboutCircle rightCenter omega (rotateAboutCircle rightCenter omega
              (rotateAboutCircle rightCenter omega z)))) := by
          rw [genB_in_disk_eq_rotateAboutCircle r z hz]
      _ = rotateAboutCircle rightCenter (omega ^ 5) z := by

          have h_iter : (rotateAboutCircle rightCenter omega)^[5] z =
              rotateAboutCircle rightCenter (omega ^ 5) z := rotateAboutCircle_pow rightCenter omega 5 z
          simp only [Function.iterate_succ, Function.iterate_zero, Function.comp_apply] at h_iter
          exact h_iter
      _ = rotateAboutCircle rightCenter 1 z := by

          have omega_pow_five : omega ^ 5 = 1 := by
            rw [homega_def]
            ext
            rw [SubmonoidClass.coe_pow, Circle.coe_exp, Circle.coe_one]
            rw [<- Complex.exp_nat_mul]

            have h_eq : (5 : Nat) * (((-2 * Real.pi / 5 : Real) : Complex) * Complex.I) =
                (-1 : Int) * (2 * Real.pi * Complex.I) := by
              push_cast
              ring
            rw [h_eq, Complex.exp_int_mul_two_pi_mul_I]
          rw [omega_pow_five]
      _ = z := rotateAboutCircle_one rightCenter z
  .
    have hgenB_id : forall w, w ∉ rightDisk r -> genB r w = w := fun w hw => by
      unfold genB
      simp only [hw, if_false]

    rw [hgenB_id z hz]

    rw [hgenB_id z hz, hgenB_id z hz, hgenB_id z hz, hgenB_id z hz]

theorem genB_bijective_proof (r : Real) : Function.Bijective (genB r) := by
  constructor
  .
    intro x y hxy
    have hx : genB r (genB r (genB r (genB r (genB r x)))) = x := genB_pow_five r x
    have hy : genB r (genB r (genB r (genB r (genB r y)))) = y := genB_pow_five r y

    have h1 : genB r (genB r x) = genB r (genB r y) := congrArg (genB r) hxy
    have h2 : genB r (genB r (genB r x)) = genB r (genB r (genB r y)) := congrArg (genB r) h1
    have h3 : genB r (genB r (genB r (genB r x))) = genB r (genB r (genB r (genB r y))) := congrArg (genB r) h2
    have h4 : genB r (genB r (genB r (genB r (genB r x)))) = genB r (genB r (genB r (genB r (genB r y)))) := congrArg (genB r) h3
    rw [hx, hy] at h4
    exact h4
  .
    intro y
    use genB r (genB r (genB r (genB r y)))
    exact genB_pow_five r y

lemma genA_perm_pow_five (r : Real) : genA_perm r ^ 5 = 1 := by
  ext z
  simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
             Function.comp_apply, Equiv.Perm.coe_one, id_eq, genA_perm_apply]
  exact genA_pow_five r z

lemma genB_perm_pow_five (r : Real) : genB_perm r ^ 5 = 1 := by
  ext z
  simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
             Function.comp_apply, Equiv.Perm.coe_one, id_eq, genB_perm_apply]
  exact genB_pow_five r z

theorem genA_n_bijective_proof (n : Nat) (hn : n >= 1) (r : Real) :
    Function.Bijective (genA_n n r) := by

  have h_period : forall z, (genA_n n r)^[n] z = z := fun z => genA_n_pow_n n hn r z
  constructor
  .
    intro x y hxy

    have h_apply : forall k, (genA_n n r)^[k] (genA_n n r x) = (genA_n n r)^[k] (genA_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genA_n n r) ih
    have h_eq : (genA_n n r)^[n] x = (genA_n n r)^[n] y := by
      calc (genA_n n r)^[n] x
          = (genA_n n r)^[n - 1] (genA_n n r x) := iterate_split (genA_n n r) n hn x
        _ = (genA_n n r)^[n - 1] (genA_n n r y) := h_apply (n - 1)
        _ = (genA_n n r)^[n] y := (iterate_split (genA_n n r) n hn y).symm
    calc x = (genA_n n r)^[n] x := (h_period x).symm
      _ = (genA_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genA_n n r)^[n - 1] y
    calc genA_n n r ((genA_n n r)^[n - 1] y)
        = (genA_n n r)^[n] y := iterate_unsplit (genA_n n r) n hn y
      _ = y := h_period y

theorem genB_n_bijective_proof (n : Nat) (hn : n >= 1) (r : Real) :
    Function.Bijective (genB_n n r) := by
  have h_period : forall z, (genB_n n r)^[n] z = z := fun z => genB_n_pow_n n hn r z
  constructor
  .
    intro x y hxy
    have h_apply : forall k, (genB_n n r)^[k] (genB_n n r x) = (genB_n n r)^[k] (genB_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genB_n n r) ih
    have h_eq : (genB_n n r)^[n] x = (genB_n n r)^[n] y := by
      calc (genB_n n r)^[n] x
          = (genB_n n r)^[n - 1] (genB_n n r x) := iterate_split (genB_n n r) n hn x
        _ = (genB_n n r)^[n - 1] (genB_n n r y) := h_apply (n - 1)
        _ = (genB_n n r)^[n] y := (iterate_split (genB_n n r) n hn y).symm
    calc x = (genB_n n r)^[n] x := (h_period x).symm
      _ = (genB_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genB_n n r)^[n - 1] y
    calc genB_n n r ((genB_n n r)^[n - 1] y)
        = (genB_n n r)^[n] y := iterate_unsplit (genB_n n r) n hn y
      _ = y := h_period y

private noncomputable def genToPerm (r : Real) : Generator -> TwoDiskCompoundSymmetryGroup 5 (by norm_num) r
  | .A => { val := genA_n_perm 5 (by norm_num) r, property := Subgroup.subset_closure (Set.mem_insert _ _) }
  | .Ainv => { val := (genA_n_perm 5 (by norm_num) r)⁻¹, property := Subgroup.inv_mem _ (Subgroup.subset_closure (Set.mem_insert _ _)) }
  | .B => { val := genB_n_perm 5 (by norm_num) r, property := Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _)) }
  | .Binv => { val := (genB_n_perm 5 (by norm_num) r)⁻¹, property := Subgroup.inv_mem _ (Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))) }

private lemma genToPerm_action (r : Real) (g : Generator) (p : Complex) :
    (genToPerm r g).val p = applyGen r p g := by
  cases g with
  | A =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk, genA_n_perm, Equiv.ofBijective_apply]
    exact genA_eq_genA_n_5 r p
  | Ainv =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk]
    have h : (genA_n_perm 5 (by norm_num) r)⁻¹ = (genA_n_perm 5 (by norm_num) r) ^ 4 := by
      have h5 : (genA_n_perm 5 (by norm_num) r) ^ 5 = 1 := by
        ext z
        simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
                   Function.comp_apply, Equiv.Perm.coe_one, id_eq]
        exact genA_n_pow_n 5 (by norm_num) r z
      calc (genA_n_perm 5 (by norm_num) r)⁻¹
          = (genA_n_perm 5 (by norm_num) r)⁻¹ * 1 := by simp
        _ = (genA_n_perm 5 (by norm_num) r)⁻¹ * (genA_n_perm 5 (by norm_num) r) ^ 5 := by rw [h5]
        _ = (genA_n_perm 5 (by norm_num) r) ^ 4 := by group
    conv_lhs => rw [h]
    simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
               Function.comp_apply, genA_n_perm, Equiv.ofBijective_apply]
    rw [genA_eq_genA_n_5, genA_eq_genA_n_5, genA_eq_genA_n_5, genA_eq_genA_n_5]
    rfl
  | B =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk, genB_n_perm, Equiv.ofBijective_apply]
    exact genB_eq_genB_n_5 r p
  | Binv =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk]
    have h : (genB_n_perm 5 (by norm_num) r)⁻¹ = (genB_n_perm 5 (by norm_num) r) ^ 4 := by
      have h5 : (genB_n_perm 5 (by norm_num) r) ^ 5 = 1 := by
        ext z
        simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
                   Function.comp_apply, Equiv.Perm.coe_one, id_eq]
        exact genB_n_pow_n 5 (by norm_num) r z
      calc (genB_n_perm 5 (by norm_num) r)⁻¹
          = (genB_n_perm 5 (by norm_num) r)⁻¹ * 1 := by simp
        _ = (genB_n_perm 5 (by norm_num) r)⁻¹ * (genB_n_perm 5 (by norm_num) r) ^ 5 := by rw [h5]
        _ = (genB_n_perm 5 (by norm_num) r) ^ 4 := by group
    conv_lhs => rw [h]
    simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
               Function.comp_apply, genB_n_perm, Equiv.ofBijective_apply]
    rw [genB_eq_genB_n_5, genB_eq_genB_n_5, genB_eq_genB_n_5, genB_eq_genB_n_5]
    rfl

private noncomputable def wordToPerm (r : Real) : Word -> TwoDiskCompoundSymmetryGroup 5 (by norm_num) r
  | [] => 1
  | g :: gs => wordToPerm r gs * genToPerm r g

private lemma wordToPerm_action (r : Real) (w : Word) (p : Complex) :
    (wordToPerm r w).val p = applyWord r w p := by
  induction w generalizing p with
  | nil =>
    simp only [wordToPerm, applyWord, List.foldl_nil]
    rfl
  | cons g gs ih =>
    simp only [wordToPerm, applyWord, List.foldl_cons]

    have h1 : (wordToPerm r gs * genToPerm r g).val p =
              (wordToPerm r gs).val ((genToPerm r g).val p) := by
      simp only [Subgroup.coe_mul, Equiv.Perm.coe_mul, Function.comp_apply]
    rw [h1, genToPerm_action, ih]
    rfl

lemma word_orbit_subset_group_orbit (r : Real) (z : Complex) :
    orbit r z ⊆ groupOrbit 5 (by norm_num) r z := by
  intro w hw
  obtain ⟨word, hw_eq⟩ := hw
  unfold groupOrbit
  rw [MulAction.mem_orbit_iff]
  use wordToPerm r word
  rw [<- hw_eq]
  exact wordToPerm_action r word z

private lemma wordToPerm_append (r : Real) (u v : Word) :
    wordToPerm r (u ++ v) = wordToPerm r v * wordToPerm r u := by
  induction u with
  | nil => simp [wordToPerm]
  | cons g gs ih =>
    simp only [List.cons_append, wordToPerm]
    rw [ih]
    group

private lemma closure_element_has_word (r : Real) (g : TwoDiskCompoundSymmetryGroup 5 (by norm_num) r) :
    exists w : Word, g.val = (wordToPerm r w).val := by
  obtain ⟨g_perm, hg⟩ := g

  refine Subgroup.closure_induction (p := fun g _ => exists w : Word, g = (wordToPerm r w).val)
    ?mem ?one ?mul ?inv hg
  case mem =>

    intro x hx
    simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx
    cases hx with
    | inl h =>

      use [Generator.A]
      rw [h]
      simp only [wordToPerm, genToPerm, one_mul, Subgroup.coe_mk]
    | inr h =>

      use [Generator.B]
      rw [h]
      simp only [wordToPerm, genToPerm, one_mul, Subgroup.coe_mk]
  case one =>

    use []
    simp only [wordToPerm, Subgroup.coe_one]
  case mul =>

    intro g' h' _ _ ⟨w1, hw1⟩ ⟨w2, hw2⟩
    use w2 ++ w1
    rw [hw1, hw2, wordToPerm_append]
    simp only [Subgroup.coe_mul]
  case inv =>

    intro g' _ ⟨w, hw⟩

    let invGen : Generator -> Generator
      | .A => .Ainv
      | .Ainv => .A
      | .B => .Binv
      | .Binv => .B
    use (w.reverse.map invGen)
    rw [hw]

    have h_invGen : forall gen, (genToPerm r (invGen gen)).val = ((genToPerm r gen).val)⁻¹ := by
      intro gen
      cases gen <;> simp only [invGen, genToPerm, Subgroup.coe_mk, inv_inv]

    have h_rev_inv : forall (v : Word),
        (wordToPerm r (v.reverse.map invGen)).val = ((wordToPerm r v).val)⁻¹ := by
      intro v
      induction v with
      | nil =>
        simp only [List.reverse_nil, List.map_nil, wordToPerm, Subgroup.coe_one, inv_one]
      | cons g gs ih =>
        simp only [List.reverse_cons, List.map_append, List.map_cons, List.map_nil, wordToPerm]
        rw [wordToPerm_append]
        simp only [wordToPerm, one_mul, Subgroup.coe_mul]
        rw [mul_inv_rev, ih, h_invGen]
    rw [<- h_rev_inv w]

lemma group_orbit_subset_word_orbit (r : Real) (z : Complex) :
    groupOrbit 5 (by norm_num) r z ⊆ orbit r z := by
  intro w hw
  unfold groupOrbit at hw
  rw [MulAction.mem_orbit_iff] at hw
  obtain ⟨g, hgw⟩ := hw

  obtain ⟨word, hword⟩ := closure_element_has_word r g

  use word
  rw [<- hgw]

  have h2 : (wordToPerm r word).val z = applyWord r word z := wordToPerm_action r word z
  calc applyWord r word z
      = (wordToPerm r word).val z := h2.symm
    _ = g.val z := by rw [<- hword]
    _ = g • z := rfl

theorem orbit_eq_groupOrbit (r : Real) (z : Complex) :
    orbit r z = groupOrbit 5 (by norm_num) r z := by
  apply Set.eq_of_subset_of_subset
  . exact word_orbit_subset_group_orbit r z
  . exact group_orbit_subset_word_orbit r z

lemma infinite_orbit_implies_infinite_group {G : Type*} [Group G] [MulAction G Complex]
    (z : Complex) (h : (MulAction.orbit G z).Infinite) : Infinite G := by
  by_contra hfin
  push_neg at hfin
  haveI : Finite G := hfin
  exact h (Finite.finite_mulAction_orbit z)

theorem CompoundSymmetryGroup_infinite_of_infinite_orbit (r : Real) (z : Complex)
    (h : (groupOrbit 5 (by norm_num) r z).Infinite) : Infinite (TwoDiskCompoundSymmetryGroup 5 (by norm_num) r) := by
  exact infinite_orbit_implies_infinite_group z h

theorem GG5_infinite_of_infinite_orbit (z : Complex)
    (h : (GG5_orbit z).Infinite) : Infinite GG5_At_Critical_radius := by
  exact CompoundSymmetryGroup_infinite_of_infinite_orbit r_crit z h

theorem GG5_has_infinite_group_orbit :
    exists z : Complex, (GG5_orbit z).Infinite := by
  obtain ⟨x0, hx0_mem, hx0_inf⟩ := GG5_IET_has_infinite_orbit
  use segmentPoint x0

  show (MulAction.orbit GG5_At_Critical_radius (segmentPoint x0)).Infinite

  have h_word_inf : (orbit r_crit (segmentPoint x0)).Infinite :=
    IET_orbit_infinite_implies_group_orbit_infinite x0 hx0_mem hx0_inf

  rw [orbit_eq_groupOrbit] at h_word_inf

  exact h_word_inf

end TDCSG.CompoundSymmetry.GG5
