/-
Copyright (c) 2024 Eric Vergo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Vergo
-/
import TDCSG.Definitions.GroupTheory
import TDCSG.Proofs.IETOrbit
import Mathlib.GroupTheory.GroupAction.Basic
import Mathlib.Data.Finite.Defs

/-!
# Group Theory for the GG5 Compound Symmetry Group

This file establishes the group structure of the two-disk compound symmetry group generated by
rotations about two disk centers, proving bijectivity of generators and the equivalence between
word orbits and group orbits.

## Main results

- `genA_bijective_proof`: The generator A (rotation about left disk) is bijective
- `genB_bijective_proof`: The generator B (rotation about right disk) is bijective
- `orbit_eq_groupOrbit`: Word orbits coincide with group-theoretic orbits
- `GG5_infinite_of_infinite_orbit`: An infinite orbit implies the group is infinite
- `GG5_has_infinite_group_orbit`: The GG5 group at critical radius has an infinite orbit

## References

* [arXiv:2302.12950v1](https://arxiv.org/abs/2302.12950)
-/

namespace TDCSG.CompoundSymmetry.GG5

open TDCSG.Definitions
open scoped Complex

theorem genA_n_bijective_proof (n : Nat) (hn : n >= 1) (r : Real) :
    Function.Bijective (genA_n n r) := by

  have h_period : forall z, (genA_n n r)^[n] z = z := fun z => genA_n_pow_n n hn r z
  constructor
  .
    intro x y hxy

    have h_apply : forall k, (genA_n n r)^[k] (genA_n n r x) = (genA_n n r)^[k] (genA_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genA_n n r) ih
    have h_eq : (genA_n n r)^[n] x = (genA_n n r)^[n] y := by
      calc (genA_n n r)^[n] x
          = (genA_n n r)^[n - 1] (genA_n n r x) := iterate_split (genA_n n r) n hn x
        _ = (genA_n n r)^[n - 1] (genA_n n r y) := h_apply (n - 1)
        _ = (genA_n n r)^[n] y := (iterate_split (genA_n n r) n hn y).symm
    calc x = (genA_n n r)^[n] x := (h_period x).symm
      _ = (genA_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genA_n n r)^[n - 1] y
    calc genA_n n r ((genA_n n r)^[n - 1] y)
        = (genA_n n r)^[n] y := iterate_unsplit (genA_n n r) n hn y
      _ = y := h_period y

theorem genB_n_bijective_proof (n : Nat) (hn : n >= 1) (r : Real) :
    Function.Bijective (genB_n n r) := by
  have h_period : forall z, (genB_n n r)^[n] z = z := fun z => genB_n_pow_n n hn r z
  constructor
  .
    intro x y hxy
    have h_apply : forall k, (genB_n n r)^[k] (genB_n n r x) = (genB_n n r)^[k] (genB_n n r y) := by
      intro k
      induction k with
      | zero => simp [hxy]
      | succ k ih =>
        simp only [Function.iterate_succ', Function.comp_apply]
        exact congrArg (genB_n n r) ih
    have h_eq : (genB_n n r)^[n] x = (genB_n n r)^[n] y := by
      calc (genB_n n r)^[n] x
          = (genB_n n r)^[n - 1] (genB_n n r x) := iterate_split (genB_n n r) n hn x
        _ = (genB_n n r)^[n - 1] (genB_n n r y) := h_apply (n - 1)
        _ = (genB_n n r)^[n] y := (iterate_split (genB_n n r) n hn y).symm
    calc x = (genB_n n r)^[n] x := (h_period x).symm
      _ = (genB_n n r)^[n] y := h_eq
      _ = y := h_period y
  .
    intro y
    use (genB_n n r)^[n - 1] y
    calc genB_n n r ((genB_n n r)^[n - 1] y)
        = (genB_n n r)^[n] y := iterate_unsplit (genB_n n r) n hn y
      _ = y := h_period y

private noncomputable def genToPerm (r : Real) : Generator -> TwoDiskCompoundSymmetryGroup 5 (by norm_num) r
  | .A => { val := genA_n_perm 5 (by norm_num) r, property := Subgroup.subset_closure (Set.mem_insert _ _) }
  | .Ainv => { val := (genA_n_perm 5 (by norm_num) r)⁻¹, property := Subgroup.inv_mem _ (Subgroup.subset_closure (Set.mem_insert _ _)) }
  | .B => { val := genB_n_perm 5 (by norm_num) r, property := Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _)) }
  | .Binv => { val := (genB_n_perm 5 (by norm_num) r)⁻¹, property := Subgroup.inv_mem _ (Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))) }

private lemma genToPerm_action (r : Real) (g : Generator) (p : Complex) :
    (genToPerm r g).val p = applyGen r p g := by
  cases g with
  | A =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk, genA_n_perm, Equiv.ofBijective_apply]
    exact genA_eq_genA_n_5 r p
  | Ainv =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk]
    have h : (genA_n_perm 5 (by norm_num) r)⁻¹ = (genA_n_perm 5 (by norm_num) r) ^ 4 := by
      have h5 : (genA_n_perm 5 (by norm_num) r) ^ 5 = 1 := by
        ext z
        simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
                   Function.comp_apply, Equiv.Perm.coe_one, id_eq]
        exact genA_n_pow_n 5 (by norm_num) r z
      calc (genA_n_perm 5 (by norm_num) r)⁻¹
          = (genA_n_perm 5 (by norm_num) r)⁻¹ * 1 := by simp
        _ = (genA_n_perm 5 (by norm_num) r)⁻¹ * (genA_n_perm 5 (by norm_num) r) ^ 5 := by rw [h5]
        _ = (genA_n_perm 5 (by norm_num) r) ^ 4 := by group
    conv_lhs => rw [h]
    simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
               Function.comp_apply, genA_n_perm, Equiv.ofBijective_apply]
    rw [genA_eq_genA_n_5, genA_eq_genA_n_5, genA_eq_genA_n_5, genA_eq_genA_n_5]
    rfl
  | B =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk, genB_n_perm, Equiv.ofBijective_apply]
    exact genB_eq_genB_n_5 r p
  | Binv =>
    simp only [genToPerm, applyGen, Subgroup.coe_mk]
    have h : (genB_n_perm 5 (by norm_num) r)⁻¹ = (genB_n_perm 5 (by norm_num) r) ^ 4 := by
      have h5 : (genB_n_perm 5 (by norm_num) r) ^ 5 = 1 := by
        ext z
        simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
                   Function.comp_apply, Equiv.Perm.coe_one, id_eq]
        exact genB_n_pow_n 5 (by norm_num) r z
      calc (genB_n_perm 5 (by norm_num) r)⁻¹
          = (genB_n_perm 5 (by norm_num) r)⁻¹ * 1 := by simp
        _ = (genB_n_perm 5 (by norm_num) r)⁻¹ * (genB_n_perm 5 (by norm_num) r) ^ 5 := by rw [h5]
        _ = (genB_n_perm 5 (by norm_num) r) ^ 4 := by group
    conv_lhs => rw [h]
    simp only [Equiv.Perm.coe_pow, Function.iterate_succ, Function.iterate_zero,
               Function.comp_apply, genB_n_perm, Equiv.ofBijective_apply]
    rw [genB_eq_genB_n_5, genB_eq_genB_n_5, genB_eq_genB_n_5, genB_eq_genB_n_5]
    rfl

private noncomputable def wordToPerm (r : Real) : Word -> TwoDiskCompoundSymmetryGroup 5 (by norm_num) r
  | [] => 1
  | g :: gs => wordToPerm r gs * genToPerm r g

private lemma wordToPerm_action (r : Real) (w : Word) (p : Complex) :
    (wordToPerm r w).val p = applyWord r w p := by
  induction w generalizing p with
  | nil =>
    simp only [wordToPerm, applyWord, List.foldl_nil]
    rfl
  | cons g gs ih =>
    simp only [wordToPerm, applyWord, List.foldl_cons]

    have h1 : (wordToPerm r gs * genToPerm r g).val p =
              (wordToPerm r gs).val ((genToPerm r g).val p) := by
      simp only [Subgroup.coe_mul, Equiv.Perm.coe_mul, Function.comp_apply]
    rw [h1, genToPerm_action, ih]
    rfl

lemma word_orbit_subset_group_orbit (r : Real) (z : Complex) :
    orbit r z ⊆ groupOrbit 5 (by norm_num) r z := by
  intro w hw
  obtain ⟨word, hw_eq⟩ := hw
  unfold groupOrbit
  rw [MulAction.mem_orbit_iff]
  use wordToPerm r word
  rw [<- hw_eq]
  exact wordToPerm_action r word z

private lemma wordToPerm_append (r : Real) (u v : Word) :
    wordToPerm r (u ++ v) = wordToPerm r v * wordToPerm r u := by
  induction u with
  | nil => simp [wordToPerm]
  | cons g gs ih =>
    simp only [List.cons_append, wordToPerm]
    rw [ih]
    group

private lemma closure_element_has_word (r : Real) (g : TwoDiskCompoundSymmetryGroup 5 (by norm_num) r) :
    exists w : Word, g.val = (wordToPerm r w).val := by
  obtain ⟨g_perm, hg⟩ := g

  refine Subgroup.closure_induction (p := fun g _ => exists w : Word, g = (wordToPerm r w).val)
    ?mem ?one ?mul ?inv hg
  case mem =>

    intro x hx
    simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx
    cases hx with
    | inl h =>

      use [Generator.A]
      rw [h]
      simp only [wordToPerm, genToPerm, one_mul, Subgroup.coe_mk]
    | inr h =>

      use [Generator.B]
      rw [h]
      simp only [wordToPerm, genToPerm, one_mul, Subgroup.coe_mk]
  case one =>

    use []
    simp only [wordToPerm, Subgroup.coe_one]
  case mul =>

    intro g' h' _ _ ⟨w1, hw1⟩ ⟨w2, hw2⟩
    use w2 ++ w1
    rw [hw1, hw2, wordToPerm_append]
    simp only [Subgroup.coe_mul]
  case inv =>

    intro g' _ ⟨w, hw⟩

    let invGen : Generator -> Generator
      | .A => .Ainv
      | .Ainv => .A
      | .B => .Binv
      | .Binv => .B
    use (w.reverse.map invGen)
    rw [hw]

    have h_invGen : forall gen, (genToPerm r (invGen gen)).val = ((genToPerm r gen).val)⁻¹ := by
      intro gen
      cases gen <;> simp only [invGen, genToPerm, Subgroup.coe_mk, inv_inv]

    have h_rev_inv : forall (v : Word),
        (wordToPerm r (v.reverse.map invGen)).val = ((wordToPerm r v).val)⁻¹ := by
      intro v
      induction v with
      | nil =>
        simp only [List.reverse_nil, List.map_nil, wordToPerm, Subgroup.coe_one, inv_one]
      | cons g gs ih =>
        simp only [List.reverse_cons, List.map_append, List.map_cons, List.map_nil, wordToPerm]
        rw [wordToPerm_append]
        simp only [wordToPerm, one_mul, Subgroup.coe_mul]
        rw [mul_inv_rev, ih, h_invGen]
    rw [<- h_rev_inv w]

lemma group_orbit_subset_word_orbit (r : Real) (z : Complex) :
    groupOrbit 5 (by norm_num) r z ⊆ orbit r z := by
  intro w hw
  unfold groupOrbit at hw
  rw [MulAction.mem_orbit_iff] at hw
  obtain ⟨g, hgw⟩ := hw

  obtain ⟨word, hword⟩ := closure_element_has_word r g

  use word
  rw [<- hgw]

  have h2 : (wordToPerm r word).val z = applyWord r word z := wordToPerm_action r word z
  calc applyWord r word z
      = (wordToPerm r word).val z := h2.symm
    _ = g.val z := by rw [<- hword]
    _ = g • z := rfl

theorem orbit_eq_groupOrbit (r : Real) (z : Complex) :
    orbit r z = groupOrbit 5 (by norm_num) r z := by
  apply Set.eq_of_subset_of_subset
  . exact word_orbit_subset_group_orbit r z
  . exact group_orbit_subset_word_orbit r z

lemma infinite_orbit_implies_infinite_group {G : Type*} [Group G] [MulAction G Complex]
    (z : Complex) (h : (MulAction.orbit G z).Infinite) : Infinite G := by
  by_contra hfin
  push_neg at hfin
  haveI : Finite G := hfin
  exact h (Finite.finite_mulAction_orbit z)

theorem CompoundSymmetryGroup_infinite_of_infinite_orbit (r : Real) (z : Complex)
    (h : (groupOrbit 5 (by norm_num) r z).Infinite) : Infinite (TwoDiskCompoundSymmetryGroup 5 (by norm_num) r) := by
  exact infinite_orbit_implies_infinite_group z h

theorem GG5_infinite_of_infinite_orbit (z : Complex)
    (h : (GG5_orbit z).Infinite) : Infinite GG5_At_Critical_radius := by
  exact CompoundSymmetryGroup_infinite_of_infinite_orbit r_crit z h

theorem GG5_has_infinite_group_orbit :
    exists z : Complex, (GG5_orbit z).Infinite := by
  obtain ⟨x0, hx0_mem, hx0_inf⟩ := GG5_IET_has_infinite_orbit
  use segmentPoint x0

  show (MulAction.orbit GG5_At_Critical_radius (segmentPoint x0)).Infinite

  have h_word_inf : (orbit r_crit (segmentPoint x0)).Infinite :=
    IET_orbit_infinite_implies_group_orbit_infinite x0 hx0_mem hx0_inf

  rw [orbit_eq_groupOrbit] at h_word_inf

  exact h_word_inf

end TDCSG.CompoundSymmetry.GG5
