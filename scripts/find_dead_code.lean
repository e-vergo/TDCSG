import TDCSG.ProofOfMainTheorem
import Lean
import Lean.Server.Rpc.Basic

open Lean Meta System Server

/-- Collect all constant names from an expression -/
partial def collectConstants (e : Expr) : Array Name :=
  e.foldConsts #[] fun name acc =>
    if name.isInternal then acc else acc.push name

/-- Check if a name is in the TDCSG namespace -/
def isTDCSGDecl (name : Name) : Bool :=
  !name.components.isEmpty && name.components.head! == `TDCSG

/-- Check if a name is a compiler-generated auxiliary declaration -/
def isAuxDecl (name : Name) : Bool :=
  let nameStr := name.toString
  -- Compiler-generated proof obligations: ._proof, ._simp, etc.
  (nameStr.splitOn "._").length > 1 ||
  -- Derived instances: instDecidableEq, instRepr, etc.
  (nameStr.splitOn "inst").length > 1 && (
    (nameStr.splitOn "Decidable").length > 1 ||
    (nameStr.splitOn "Repr").length > 1 ||
    (nameStr.splitOn "Inhabited").length > 1 ||
    (nameStr.splitOn "BEq").length > 1
  ) ||
  -- Macro expansions
  (nameStr.splitOn "_aux_").length > 1 ||
  (nameStr.splitOn "macroRules").length > 1 ||
  (nameStr.splitOn "«").length > 1  -- Escaped identifiers from macros

/-- Check if a name is from an auto-generated module (e.g., GG5) -/
def isAutoGenerated (name : Name) : Bool :=
  let nameStr := name.toString
  -- GG5 module is auto-generated and should be excluded from dead code reports
  nameStr.startsWith "TDCSG.CompoundSymmetry.GG5."

/-- Get the declaration kind as a string -/
def getDeclKindStr (info : ConstantInfo) : String :=
  match info with
  | .defnInfo _ => "def"
  | .thmInfo _ => "theorem"
  | .axiomInfo _ => "axiom"
  | .inductInfo _ => "inductive"
  | .ctorInfo _ => "constructor"
  | .recInfo _ => "recursor"
  | .quotInfo _ => "quot"
  | .opaqueInfo _ => "opaque"

/-- Check if a declaration name suggests it might have attributes -/
def likelyHasAttributes (declName : String) : Bool :=
  -- Heuristic: declarations ending in certain patterns are likely attributed
  declName.endsWith "_simp" || declName.endsWith "_ext" ||
  (declName.splitOn "_instance").length > 1 ||
  (declName.splitOn "inst").length > 1

/-- Get direct dependencies of a declaration -/
def getDirectDeps (env : Environment) (name : Name) : Array Name :=
  match env.find? name with
  | none => #[]
  | some info =>
    let typeConsts := collectConstants info.type
    let valueConsts := match info with
      | .defnInfo val => collectConstants val.value
      | .thmInfo val => collectConstants val.value
      | _ => #[]
    (typeConsts ++ valueConsts).filter (fun n => isTDCSGDecl n && !isAuxDecl n)

/-- Get all transitive dependencies starting from a root declaration -/
def getTransitiveDeps (env : Environment) (root : Name) : IO (Std.HashSet Name) := do
  let mut visited : Std.HashSet Name := {}
  let mut worklist : Array Name := #[root]
  let mut idx := 0

  while idx < worklist.size do
    let current := worklist[idx]!
    idx := idx + 1

    if visited.contains current then
      continue

    visited := visited.insert current

    -- Get dependencies
    let deps := getDirectDeps env current
    for dep in deps do
      if !visited.contains dep then
        worklist := worklist.push dep

  return visited

/-- Get all TDCSG declarations from environment (excluding auxiliary) -/
def getAllTDCSGDecls (env : Environment) : Array Name :=
  env.constants.map₁.toArray.filterMap fun (name, _) =>
    if isTDCSGDecl name && !isAuxDecl name then some name else none

/-- Search all TDCSG .lean files for a declaration -/
def findDeclarationInFiles (declName : String) : IO (Option (String × Nat)) := do
  -- Get all .lean files in TDCSG directory
  let dirs := #["TDCSG/Definitions", "TDCSG/Proofs", "TDCSG"]

  for dir in dirs do
    if !(← System.FilePath.pathExists dir) then
      continue

    let files ← System.FilePath.readDir dir
    for file in files do
      if file.path.toString.endsWith ".lean" then
        try
          let content ← IO.FS.readFile file.path.toString
          let linesArray := (content.splitOn "\n").toArray

          -- Search for the declaration
          for i in [0:linesArray.size] do
            let line := linesArray[i]!
            -- Check if line contains declaration keywords followed by our name
            if (line.splitOn declName).length > 1 then
              let keywords := ["def ", "theorem ", "lemma ", "axiom ", "inductive ", "structure "]
              if keywords.any (fun kw => (line.splitOn kw).length > 1) then
                return some (file.path.toString, i + 1)
        catch _ =>
          continue

  return none

def main : IO Unit := do
  initSearchPath (← findSysroot)

  let env ← importModules #[{module := `TDCSG.MainTheorem}, {module := `TDCSG.ProofOfMainTheorem}] {} 0

  -- Get all TDCSG declarations
  let allDecls := getAllTDCSGDecls env
  IO.eprintln s!"Total TDCSG declarations: {allDecls.size}"

  -- Find the proof theorem
  let mut proofTheoremOpt : Option Name := none
  let candidates := #[
    `GG5_infinite_at_critical_radius,
    `TDCSG.ProofOfMainTheorem.GG5_infinite_at_critical_radius,
    `TDCSG.GG5_infinite_at_critical_radius
  ]

  for candidate in candidates do
    if env.find? candidate |>.isSome then
      proofTheoremOpt := some candidate
      break

  -- MainTheorem.lean declarations (at root level, no namespace)
  let mainTheoremNames := #[
    `StatementOfTheorem,
    `GG5_At_Critical_radius,
    `TwoDiskCompoundSymmetryGroup,
    `genA_n_perm,
    `genB_n_perm
  ]

  -- Start reachability analysis from both proof and MainTheorem declarations
  let mut reachable : Std.HashSet Name := {}

  -- Trace from proof theorem
  match proofTheoremOpt with
  | some proofTheorem =>
    IO.eprintln s!"Proof theorem: {proofTheorem}"
    reachable := reachable.insert proofTheorem
    let proofReachable ← getTransitiveDeps env proofTheorem
    for name in proofReachable.toArray do
      reachable := reachable.insert name
  | none =>
    IO.eprintln "Warning: Proof theorem not found"

  -- Trace from MainTheorem declarations
  IO.eprintln "Tracing MainTheorem declarations..."
  for name in mainTheoremNames do
    if env.find? name |>.isSome then
      IO.eprintln s!"  Found: {name}"
      reachable := reachable.insert name
      let deps ← getTransitiveDeps env name
      for dep in deps.toArray do
        reachable := reachable.insert dep
    else
      IO.eprintln s!"  Not found: {name}"

  IO.eprintln s!"Total reachable from MainTheorem + Proof: {reachable.size}"

  -- Find dead code (declarations not reachable from main theorem)
  -- Exclude auto-generated modules (like GG5)
  let mut deadCodeList : Array Name := #[]
  let mut allDeclSet : Std.HashSet Name := {}
  for name in allDecls do
    allDeclSet := allDeclSet.insert name
    if !reachable.contains name && !isAutoGenerated name then
      deadCodeList := deadCodeList.push name

  let deadCode := deadCodeList.qsort (·.toString < ·.toString)

  IO.eprintln s!"Dead code: {deadCode.size}"
  IO.eprintln ""

  -- Print summary
  IO.println "=== DEAD CODE ANALYSIS ==="
  IO.println ""
  IO.println s!"Total declarations: {allDecls.size}"
  IO.println s!"Reachable from main theorem: {reachable.size} ({(reachable.size * 100) / allDecls.size}%)"
  IO.println s!"Dead code: {deadCode.size} ({(deadCode.size * 100) / allDecls.size}%)"
  IO.println ""

  -- Group by module (using first 3 components of name as approximation)
  let mut byModule : Std.HashMap String Nat := {}
  for name in deadCode do
    let components := name.components
    let moduleKey := if _ : components.length >= 3 then
      -- TDCSG.Definitions.Core or TDCSG.Proofs.GroupTheory
      s!"{components[0]!}.{components[1]!}.{components[2]!}"
    else if _ : components.length >= 2 then
      s!"{components[0]!}.{components[1]!}"
    else
      components[0]!.toString

    let currentCount := byModule.getD moduleKey 0
    byModule := byModule.insert moduleKey (currentCount + 1)

  IO.println "=== DEAD CODE BY MODULE (Top 20) ==="
  let moduleList := byModule.toList.insertionSort (fun a b => a.2 > b.2)
  let top20 := moduleList.take 20
  for (module, count) in top20 do
    IO.println s!"  {module}: {count} declarations"

  if moduleList.length > 20 then
    IO.println s!"  ... and {moduleList.length - 20} more modules"

  -- Group by file for human-readable report
  let mut byFile : Std.HashMap String (Array (Name × String × Nat)) := {}
  for name in deadCode do
    let declName := name.components.getLast!.toString
    match ← findDeclarationInFiles declName with
    | some (file, line) =>
      let kind := match env.find? name with
        | some info => getDeclKindStr info
        | none => "unknown"
      let current := byFile.getD file #[]
      byFile := byFile.insert file (current.push (name, kind, line))
    | none => pure ()

  -- Save detailed report
  let h ← IO.FS.Handle.mk "docs/dead_code_analysis.md" IO.FS.Mode.write
  h.putStrLn "# Dead Code Analysis Report"
  h.putStrLn ""
  h.putStrLn s!"**Generated**: {← IO.monoMsNow}"
  h.putStrLn s!"**Total declarations**: {allDecls.size}"
  h.putStrLn s!"**Reachable from main theorem**: {reachable.size} ({(reachable.size * 100) / allDecls.size}%)"
  h.putStrLn s!"**Unreachable (dead code)**: {deadCode.size} ({(deadCode.size * 100) / allDecls.size}%)"
  h.putStrLn ""
  h.putStrLn "> **Note**: Auto-generated modules (e.g., `TDCSG.CompoundSymmetry.GG5`) are excluded from this report."
  h.putStrLn ""
  h.putStrLn "## ⚠️ IMPORTANT WARNINGS"
  h.putStrLn ""
  h.putStrLn "1. **@[simp] lemmas**: Run `python3 scripts/check_simp_attrs.py` to identify declarations with @[simp] attributes"
  h.putStrLn "   - See `docs/dead_code_safety.txt` for the list of @[simp] declarations"
  h.putStrLn "   - `@[simp]` lemmas are used implicitly by tactics and MUST NOT be deleted"
  h.putStrLn ""
  h.putStrLn "2. **Supporting lemmas**: Some unreachable lemmas may be:"
  h.putStrLn "   - Alternative proof approaches kept for reference"
  h.putStrLn "   - Exploratory work that may be useful later"
  h.putStrLn "   - General-purpose utilities not yet needed"
  h.putStrLn ""
  h.putStrLn "3. **Before deleting**: Always run `lake build` after deletions to verify"
  h.putStrLn ""
  h.putStrLn "## Unreachable Declarations by File"
  h.putStrLn ""

  let fileList := byFile.toList.insertionSort (fun a b => a.2.size > b.2.size)
  for (file, decls) in fileList do
    let sortedDecls := decls.qsort (fun a b => a.2.2 < b.2.2)  -- Sort by line number
    h.putStrLn s!"### {file} ({sortedDecls.size} declarations)"
    h.putStrLn ""
    for (name, kind, line) in sortedDecls do
      let shortName := name.components.getLast!.toString
      let safety := if likelyHasAttributes shortName then
        " **⚠️ UNSAFE - May have @[simp] or other attributes**"
      else if kind == "theorem" || kind == "lemma" then
        " ⚠️ Check for @[simp]"
      else
        ""
      h.putStrLn s!"- `{name}` ({kind}) - Line {line}{safety}"
    h.putStrLn ""

  h.putStrLn "## Summary by Module"
  h.putStrLn ""
  for (module, count) in moduleList do
    h.putStrLn s!"- `{module}`: {count} declarations"
  h.putStrLn ""

  h.putStrLn "## Recommendations"
  h.putStrLn ""
  h.putStrLn "1. **Check for @[simp] attributes**: Run `python3 scripts/check_simp_attrs.py` first"
  h.putStrLn "   - Review `docs/dead_code_safety.txt` for declarations that MUST NOT be deleted"
  h.putStrLn "2. **Safe to delete**: `def` declarations without special attributes"
  h.putStrLn "3. **Risky to delete**: Theorems/lemmas (check for @[simp] first)"
  h.putStrLn "4. **After deletion**: Run `lake build && lake env lean --run KMVerify/Main.lean`"
  h.flush

  -- Also save simple list format
  let hSimple ← IO.FS.Handle.mk "docs/dead_code.txt" IO.FS.Mode.write
  hSimple.putStrLn s!"Total: {allDecls.size} | Reachable: {reachable.size} | Dead: {deadCode.size}"
  hSimple.putStrLn ""
  hSimple.putStrLn "=== ALL UNREACHABLE DECLARATIONS ==="
  for name in deadCode do
    match env.find? name with
    | some info =>
      let kind := getDeclKindStr info
      let declName := name.components.getLast!.toString
      let locationOpt ← findDeclarationInFiles declName
      let locationInfo := match locationOpt with
        | some (file, line) => s!" ({file}:{line})"
        | none => ""
      hSimple.putStrLn s!"{name} ({kind}){locationInfo}"
    | none => hSimple.putStrLn s!"{name}"
  hSimple.flush

  IO.println ""
  IO.println "Reports saved:"
  IO.println "  docs/dead_code_analysis.md (human-readable with safety warnings)"
  IO.println "  docs/dead_code.txt (simple list format)"
