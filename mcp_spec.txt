# BFS-Prover MCP Server Specification

## Overview

This document specifies an MCP (Model Context Protocol) server that exposes BFS-Prover-V2 tactic generation capabilities as tools for Claude Code integration with Lean 4 theorem proving.

**Architecture:** Companion MCP pattern
- `lean-lsp-mcp`: Handles Lean environment interaction (goal states, verification, file operations)
- `bfs-prover-mcp`: Handles ML-powered tactic generation via local BFS-Prover model
- Claude Code: Orchestrates workflow between both MCPs

## System Requirements

- **Hardware:** M2 Ultra Mac with 64GB unified memory
- **Model:** BFS-Prover-V2-32B-GGUF (~14GB in memory when loaded)
- **Python:** Python 3.x with `.venv` environment
- **Existing Infrastructure:**
  - `tactic_server.py` daemon on port 5678
  - `tactic_query.py` client script
  - `tactic_server.sh` management script

**Note:** File structure shows both `BFS-Prover-V2-7B/` and `BFS-Prover-V2-32B-GGUF/` directories. Clarify which model is active.

## MCP Server Specification

### Server Metadata

```json
{
  "name": "bfs-prover-mcp",
  "version": "0.1.0",
  "description": "BFS-Prover-V2 tactic generation for Lean 4 theorem proving",
  "transport": "stdio"
}
```

### Installation & Setup

**Location:** `bfs_prover_mcp/` subdirectory in project root

**Structure:**
```
bfs_prover_mcp/
â”œâ”€â”€ server.py          # Main MCP server
â”œâ”€â”€ client.py          # Socket client for tactic_server.py
â”œâ”€â”€ __init__.py
â””â”€â”€ README.md
```

**Dependencies:**
- `mcp` library (Model Context Protocol SDK)
- Python standard library (`socket`, `json`, `subprocess`)
- No additional ML dependencies (uses existing daemon)

### Tool Definitions

#### 1. `bfs_suggest_tactics`

**Description:** Generate Lean 4 tactic suggestions for a given proof state using the BFS-Prover-V2 model.

**Parameters:**
```json
{
  "proof_state": {
    "type": "string",
    "description": "The Lean proof state/goal obtained from lean_goal tool. Should include hypotheses and goals in Lean format.",
    "required": true
  },
  "num_suggestions": {
    "type": "integer",
    "description": "Number of tactic suggestions to generate (1-10)",
    "default": 5,
    "required": false
  },
  "temperature": {
    "type": "number",
    "description": "Sampling temperature (0.0-1.0). Lower = more deterministic, higher = more creative",
    "default": 0.7,
    "required": false
  },
  "max_tokens": {
    "type": "integer",
    "description": "Maximum tokens per tactic",
    "default": 128,
    "required": false
  },
  "format": {
    "type": "string",
    "enum": ["lines", "json"],
    "description": "Output format",
    "default": "lines",
    "required": false
  }
}
```

**Returns:**
```json
{
  "tactics": ["tactic1", "tactic2", "..."],
  "generation_time": 2.34,
  "daemon_status": "running",
  "model_info": "BFS-Prover-V2-32B"
}
```

**Error Handling:**
- If daemon not running: Return error with suggestion to run `tactic_server.sh start`
- If socket connection fails: Return connection error details
- If invalid proof state: Return validation error

**Implementation:**
```python
async def bfs_suggest_tactics(proof_state: str, num_suggestions: int = 5, 
                               temperature: float = 0.7, max_tokens: int = 128,
                               format: str = "lines") -> dict:
    """
    Connects to existing tactic_server.py daemon via socket (port 5678)
    Sends request, receives tactics, formats response
    """
    # Validate inputs
    # Connect to socket
    # Send request to daemon
    # Parse response
    # Return formatted result
```

#### 2. `bfs_daemon_status`

**Description:** Check if the BFS-Prover daemon is running and responsive.

**Parameters:** None

**Returns:**
```json
{
  "status": "running" | "stopped" | "unresponsive",
  "port": 5678,
  "pid": 12345,
  "uptime_seconds": 3600,
  "model_loaded": true
}
```

**Implementation:**
```python
async def bfs_daemon_status() -> dict:
    """
    Checks .tactic_server.pid file
    Attempts socket connection to port 5678
    Returns status information
    """
```

#### 3. `bfs_evaluate_tactic`

**Description:** Get confidence score for a specific tactic given a proof state (future enhancement).

**Status:** Optional for v0.1.0, include stub for future implementation

**Parameters:**
```json
{
  "proof_state": {
    "type": "string",
    "required": true
  },
  "tactic": {
    "type": "string",
    "description": "Single tactic to evaluate",
    "required": true
  }
}
```

**Returns:**
```json
{
  "tactic": "linarith",
  "confidence_score": 0.87,
  "note": "Feature not yet implemented in daemon"
}
```

## Communication Protocol

### Socket Communication with `tactic_server.py`

**Connection:**
- Protocol: TCP socket
- Host: `localhost`
- Port: `5678`
- Format: JSON messages with newline delimiter

**Request Format:**
```json
{
  "method": "generate",
  "params": {
    "proof_state": "n : â„•\nh : n > 0\nâŠ¢ n + 1 > 0",
    "num_suggestions": 5,
    "temperature": 0.7,
    "max_tokens": 128
  }
}
```

**Response Format:**
```json
{
  "tactics": ["linarith", "omega", "simp_arith", "..."],
  "time": 2.1,
  "status": "success"
}
```

**Error Response:**
```json
{
  "error": "error_message",
  "status": "error"
}
```

## Typical Workflow

### Claude Code Integration Pattern

```python
# 1. Ensure daemon is running (one-time per session)
daemon_status = mcp__bfs_prover__bfs_daemon_status()
if daemon_status["status"] != "running":
    bash("./tactic_server.sh start")
    # Wait 15-20s for model loading
    time.sleep(15)

# 2. Get proof state from Lean
goal = mcp__lean_lsp__lean_goal(
    file_path="TDCSG.lean", 
    line=42, 
    column=5
)

# 3. Generate tactic suggestions
result = mcp__bfs_prover__bfs_suggest_tactics(
    proof_state=goal,
    num_suggestions=5,
    temperature=0.7
)

# 4. Test all suggestions with lean-lsp
tactics = result["tactics"]
test_results = mcp__lean_lsp__lean_multi_attempt(
    file_path="TDCSG.lean",
    line=42,
    snippets=tactics
)

# 5. Analyze results and select best tactic
# (Check which tactics compile, make progress on goals)

# 6. Apply winning tactic to file
Edit(
    file_path="TDCSG.lean",
    old_string="  sorry",
    new_string=f"  {best_tactic}"
)

# 7. Verify proof compiles
diagnostics = mcp__lean_lsp__lean_diagnostic_messages("TDCSG.lean")
```

### Multi-Step Proof Iteration

```python
# After applying first tactic, get new goal state
goal_2 = mcp__lean_lsp__lean_goal("TDCSG.lean", line=43)

# Generate tactics for new state
result_2 = mcp__bfs_prover__bfs_suggest_tactics(
    proof_state=goal_2,
    num_suggestions=5
)

# Continue iteration until proof complete
```

## Configuration

### MCP Server Configuration (`.mcp.json`)

```json
{
  "mcpServers": {
    "bfs-prover": {
      "command": "python",
      "args": ["-m", "bfs_prover_mcp.server"],
      "env": {
        "TACTIC_SERVER_PORT": "5678",
        "TACTIC_SERVER_HOST": "localhost"
      }
    }
  }
}
```

### Environment Variables

- `TACTIC_SERVER_PORT`: Port for daemon socket (default: 5678)
- `TACTIC_SERVER_HOST`: Host for daemon (default: localhost)
- `TACTIC_SERVER_TIMEOUT`: Socket timeout in seconds (default: 30)

## Implementation Guidelines

### Phase 1: Core Functionality (MVP)

**Files to create:**
1. `bfs_prover_mcp/server.py` - Main MCP server with tool definitions
2. `bfs_prover_mcp/client.py` - Socket client for daemon communication
3. `bfs_prover_mcp/__init__.py` - Package initialization
4. `bfs_prover_mcp/README.md` - Usage documentation

**Key Features:**
- `bfs_suggest_tactics` tool (fully functional)
- `bfs_daemon_status` tool (fully functional)
- Error handling for daemon not running
- JSON and line-based output formats

**Testing:**
- Unit tests for socket communication
- Integration test with running daemon
- Error case testing (daemon down, invalid input)

### Phase 2: Enhanced Features (Future)

- `bfs_evaluate_tactic` tool (requires daemon extension)
- Caching of recent requests
- Batch tactic generation
- Performance metrics logging

### Error Handling Patterns

**Daemon Not Running:**
```python
{
  "error": "BFS-Prover daemon not running",
  "suggestion": "Run './tactic_server.sh start' to start the daemon",
  "status": "daemon_down"
}
```

**Socket Timeout:**
```python
{
  "error": "Daemon request timeout after 30s",
  "suggestion": "Daemon may be overloaded. Try './tactic_server.sh restart'",
  "status": "timeout"
}
```

**Invalid Proof State:**
```python
{
  "error": "Invalid proof state format",
  "details": "Proof state must be a non-empty string",
  "status": "invalid_input"
}
```

### Resource Management

**Model Memory:**
- BFS-Prover-V2-32B: ~14GB RAM when loaded
- Total system memory: 64GB
- Available for other processes: ~50GB
- Safe for single-agent usage

**Daemon Lifecycle:**
- Start: `./tactic_server.sh start` (15-20s loading time)
- Query: 2-5s per request (fast)
- Stop: `./tactic_server.sh stop` (frees 14GB)

**Best Practices:**
- Start daemon once per Claude Code session
- Reuse for all tactic generation requests
- Stop daemon when session ends
- Monitor memory if other heavy processes running

## Success Criteria

### Functional Requirements
- âœ… MCP server responds to tool calls
- âœ… Successfully communicates with tactic daemon
- âœ… Returns valid JSON responses
- âœ… Handles daemon down scenario gracefully
- âœ… Integrates with lean-lsp-mcp workflow

### Performance Requirements
- Response time: < 5s per tactic generation request
- Daemon startup: < 20s
- Memory usage: < 16GB (including daemon)
- Uptime: Daemon stable for 1+ hour sessions

### Quality Metrics
- ~50% tactics compile without errors (baseline)
- ~20% tactics make proof progress (baseline)
- 0 crashes or hangs during normal operation
- Clear error messages for all failure modes

## Known Limitations

âš ï¸ **Model Limitations:**
- Trained on older mathlib4 - some lemmas may be outdated
- No project context - doesn't know custom lemmas
- Single-line tactics only (multi-line may fail in `lean_multi_attempt`)
- Suggestions are inspiration, not guaranteed correct

âš ï¸ **System Limitations:**
- Single model instance only (M2 Ultra 64GB constraint)
- No parallel agent search
- No planning/subgoal decomposition
- Daemon must be manually managed (start/stop)

âš ï¸ **Integration Limitations:**
- Requires both `lean-lsp-mcp` and `bfs-prover-mcp` active
- Claude Code must orchestrate between MCPs
- No direct communication between MCP servers

## Testing Strategy

### Unit Tests
- Socket connection logic
- JSON serialization/deserialization
- Error handling paths
- Parameter validation

### Integration Tests
- End-to-end tactic generation with daemon
- Daemon status checking
- Multi-request session
- Daemon restart scenarios

### Manual Testing Checklist
```bash
# 1. Start daemon
./tactic_server.sh start

# 2. Test MCP tool via Claude Code
mcp__bfs_prover__bfs_daemon_status()
# Expected: {"status": "running", ...}

# 3. Generate tactics for simple goal
mcp__bfs_prover__bfs_suggest_tactics(
    proof_state="n : â„•\nâŠ¢ n + 0 = n",
    num_suggestions=3
)
# Expected: ["simp", "rfl", "ring"] or similar

# 4. Test error case - stop daemon
./tactic_server.sh stop
mcp__bfs_prover__bfs_suggest_tactics(...)
# Expected: Error with suggestion to start daemon

# 5. Restart and verify recovery
./tactic_server.sh start
# Wait 15s
mcp__bfs_prover__bfs_suggest_tactics(...)
# Expected: Success
```

## Documentation Requirements

### README.md
- Installation instructions
- Quick start guide
- Tool reference
- Example workflows
- Troubleshooting

### Inline Code Documentation
- Docstrings for all functions
- Type hints throughout
- Comments for complex logic

### User Guide (for Claude Code)
- When to use BFS-Prover MCP
- Integration patterns with lean-lsp
- Best practices for proof automation
- Temperature tuning guidelines

## Development Roadmap

### v0.1.0 - MVP (Current Spec)
- âœ… `bfs_suggest_tactics` tool
- âœ… `bfs_daemon_status` tool
- âœ… Socket-based daemon communication
- âœ… Error handling
- âœ… Basic documentation

### v0.2.0 - Enhanced
- ðŸ”„ Request caching
- ðŸ”„ Performance metrics
- ðŸ”„ `bfs_evaluate_tactic` implementation
- ðŸ”„ Automatic daemon management

### v0.3.0 - Advanced
- ðŸ”„ Batch tactic generation
- ðŸ”„ Proof step tracking
- ðŸ”„ Success rate analytics
- ðŸ”„ Model version detection

## Appendix: File Structure

```
project_root/
â”œâ”€â”€ .mcp.json                      # MCP server configuration
â”œâ”€â”€ bfs_prover_mcp/                # NEW: MCP server package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ server.py                  # Main MCP server
â”‚   â”œâ”€â”€ client.py                  # Daemon socket client
â”‚   â””â”€â”€ README.md                  # MCP usage docs
â”œâ”€â”€ BFS-Prover-V2-7B/              # 7B model (if used)
â”œâ”€â”€ BFS-Prover-V2-32B-GGUF/        # 32B model (if used)
â”œâ”€â”€ tactic_server.py               # Existing daemon server
â”œâ”€â”€ tactic_query.py                # Existing daemon client
â”œâ”€â”€ tactic_server.sh               # Existing management script
â”œâ”€â”€ BFS_inference.py               # Existing inference logic
â””â”€â”€ TACTIC_SUGGEST_README.md       # Existing documentation
```

## Implementation Checklist

**Pre-Development:**
- [ ] Clarify which model is active (7B vs 32B-GGUF)
- [ ] Verify daemon socket protocol with test connection
- [ ] Review lean-lsp-mcp tool interface for integration patterns

**Development:**
- [ ] Create `bfs_prover_mcp/` package structure
- [ ] Implement socket client (`client.py`)
- [ ] Implement MCP server (`server.py`)
- [ ] Implement `bfs_suggest_tactics` tool
- [ ] Implement `bfs_daemon_status` tool
- [ ] Add error handling for all failure modes
- [ ] Write unit tests
- [ ] Write integration tests
- [ ] Document all code with docstrings

**Testing:**
- [ ] Test with daemon running (normal case)
- [ ] Test with daemon stopped (error case)
- [ ] Test with invalid inputs (validation)
- [ ] Test multi-request session (stability)
- [ ] Test end-to-end with lean-lsp integration

**Documentation:**
- [ ] Write MCP README.md
- [ ] Update project-level documentation
- [ ] Create usage examples for Claude Code
- [ ] Document troubleshooting steps

**Deployment:**
- [ ] Add to `.mcp.json` configuration
- [ ] Test in Claude Code environment
- [ ] Verify with real Lean proofs
- [ ] Create quick reference guide

---

**This specification is ready for implementation by Claude Code or a development team. All design decisions prioritize simplicity, reliability, and integration with existing infrastructure.**